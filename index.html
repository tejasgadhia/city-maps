<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MapToPoster — City Map Poster Generator</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%234a9eff'/><path d='M50 20c-11 0-20 9-20 20 0 15 20 35 20 35s20-20 20-35c0-11-9-20-20-20zm0 28a8 8 0 1 1 0-16 8 8 0 0 1 0 16z' fill='white'/></svg>">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #0a0a0a;
      --bg2: #141414;
      --bg3: #1e1e1e;
      --card: #161616;
      --border: #2a2a2a;
      --text: #e5e5e5;
      --text2: #888;
      --text3: #555;
      --accent: #4a9eff;
      --radius: 12px;
    }
    
    [data-ui="classic"] {
      --bg: #e8e4dc;
      --bg2: #f0ece4;
      --bg3: #f8f6f1;
      --card: #fff;
      --border: #d4cfc4;
      --text: #2c2416;
      --text2: #5a5347;
      --text3: #8a8478;
      --accent: #2d7a54;
    }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      transition: background 0.3s, color 0.3s;
    }
    
    /* === THREE COLUMN LAYOUT === */
    .app {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      grid-template-rows: auto 1fr;
      height: 100vh;
      gap: 0;
    }
    
    /* === HEADER === */
    .header {
      grid-column: 1 / -1;
      padding: 12px 20px;
      background: var(--bg2);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .logo-group {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    .logo {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    .tagline {
      font-size: 12px;
      color: var(--text3);
      font-weight: 400;
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .theme-toggle {
      display: flex;
      background: var(--bg3);
      border-radius: 8px;
      padding: 3px;
      border: 1px solid var(--border);
    }
    .theme-toggle button {
      padding: 6px 12px;
      border: none;
      background: transparent;
      color: var(--text3);
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }
    .theme-toggle button.active { background: var(--accent); color: #fff; }
    .theme-toggle button:hover:not(.active) { color: var(--text); }
    
    /* === LEFT COLUMN: CITIES === */
    .col-cities {
      background: var(--bg2);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .col-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }
    .col-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text3);
      font-weight: 600;
    }
    .city-search {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .city-search input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
    }
    .city-search input:focus { outline: none; border-color: var(--accent); }
    .city-search input::placeholder { color: var(--text3); }
    .city-filters {
      display: flex;
      gap: 6px;
    }
    .city-filters select {
      flex: 1;
      padding: 7px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text2);
      font-size: 11px;
      cursor: pointer;
    }
    .city-count {
      padding: 0 16px 8px;
      font-size: 11px;
      color: var(--text3);
    }
    .city-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 8px 8px;
    }
    
    /* Region Groups (Collapsible) */
    .region-group {
      margin-bottom: 4px;
    }
    .region-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg3);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
    }
    .region-header:hover { background: var(--border); }
    .region-header .region-name {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text2);
    }
    .region-header .region-count {
      font-size: 10px;
      color: var(--text3);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .region-header .chevron {
      transition: transform 0.2s;
      font-size: 10px;
    }
    .region-group.collapsed .chevron { transform: rotate(-90deg); }
    .region-group.collapsed .region-cities { display: none; }
    .region-cities {
      padding: 4px 0 4px 8px;
    }
    
    .city-item {
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      margin-bottom: 2px;
    }
    .city-item:focus-visible,
    .region-header:focus-visible,
    .btn:focus-visible,
    select:focus-visible,
    input:focus-visible,
    textarea:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .city-item:hover { background: var(--bg3); }
    .city-item.active { background: var(--accent); }
    .city-item .name { font-size: 13px; font-weight: 500; }
    .city-item .country { font-size: 11px; color: var(--text3); margin-top: 1px; }
    .city-item.active .name { color: #fff; }
    .city-item.active .country { color: rgba(255,255,255,0.7); }
    
    /* Custom Dropdown Styling */
    .custom-select {
      position: relative;
    }
    .custom-select select {
      appearance: none;
      -webkit-appearance: none;
      width: 100%;
      padding: 8px 28px 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .custom-select select:hover { border-color: var(--text3); }
    .custom-select select:focus { outline: none; border-color: var(--accent); }
    .custom-select::after {
      content: '▾';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--text3);
      font-size: 10px;
    }
    
    /* === CENTER: PREVIEW === */
    .col-preview {
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 20px;
    }
    .canvas-wrapper {
      position: relative;
      display: inline-block;
    }
    #preview {
      max-width: 100%;
      max-height: 100%;
      border-radius: 4px;
      border: 2px solid var(--border);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      cursor: grab;
    }
    #preview:active { cursor: grabbing; }
    
    /* Grid Overlay */
    .grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: none;
      border-radius: 4px;
      overflow: hidden;
      z-index: 5;
    }
    .grid-overlay.visible { display: block; }
    .grid-overlay .center-h,
    .grid-overlay .center-v {
      position: absolute;
      background: rgba(74, 158, 255, 0.6);
    }
    .grid-overlay .center-h {
      left: 0;
      right: 0;
      top: 50%;
      height: 1px;
      transform: translateY(-50%);
    }
    .grid-overlay .center-v {
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      transform: translateX(-50%);
    }
    .grid-overlay .grid-lines {
      position: absolute;
      inset: 0;
      background-image: 
        linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 10% 10%;
    }
    
    /* Snap indicator */
    .snap-indicator {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: #fff;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 10px;
      opacity: 0;
      transition: opacity 0.15s;
      pointer-events: none;
    }
    .snap-indicator.visible { opacity: 1; }
    
    /* Canvas toolbar */
    .canvas-toolbar {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      background: var(--card);
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 20;
      max-width: calc(100% - 32px);
    }
    .canvas-toolbar.visible { display: flex; }
    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .toolbar-group label {
      font-size: 10px;
      color: var(--text3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-right: 6px;
    }
    .canvas-toolbar button {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--bg3);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }
    .canvas-toolbar button:hover { background: var(--accent); color: #fff; }
    .canvas-toolbar button.active { background: var(--accent); color: #fff; }
    .canvas-toolbar .divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }
    .canvas-toolbar span.zoom-val {
      font-size: 11px;
      color: var(--text2);
      min-width: 45px;
      text-align: center;
    }
    .canvas-toolbar .pill-mini {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      background: var(--bg);
      border-radius: 6px;
      padding: 2px;
      border: 1px solid var(--border);
    }
    .canvas-toolbar .pill-mini input { display: none; }
    .canvas-toolbar .pill-mini label {
      padding: 6px 10px;
      font-size: 11px;
      color: var(--text2);
      border-radius: 4px;
      cursor: pointer;
      margin: 0;
      text-transform: none;
      letter-spacing: 0;
    }
    .canvas-toolbar .pill-mini input:checked + label {
      background: var(--accent);
      color: #fff;
    }
    .status-bar {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card);
      padding: 10px 20px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 13px;
      color: var(--text2);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .status-bar.loading {
      color: var(--accent);
      background: var(--bg2);
      border-color: var(--accent);
      font-weight: 500;
    }
    .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: var(--bg3);
      display: none;
    }
    .progress.active { display: block; }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #6ab0ff);
      width: 0%;
      transition: width 0.3s;
      box-shadow: 0 0 10px var(--accent);
    }
    
    /* Loading overlay - comprehensive design */
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .loading-overlay.hidden { display: none; }
    
    .loading-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 32px 40px;
      min-width: 340px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    .loading-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 24px;
    }
    .loading-header .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .loading-header .title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Steps */
    .loading-steps {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }
    .loading-step {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .loading-step .step-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      background: var(--bg3);
      color: var(--text3);
      border: 2px solid var(--border);
      flex-shrink: 0;
      transition: all 0.3s;
    }
    .loading-step.active .step-icon {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .loading-step.complete .step-icon {
      background: #22c55e;
      border-color: #22c55e;
      color: #fff;
    }
    .loading-step .step-content {
      flex: 1;
    }
    .loading-step .step-title {
      font-size: 13px;
      color: var(--text3);
      transition: color 0.3s;
    }
    .loading-step.active .step-title,
    .loading-step.complete .step-title {
      color: var(--text);
      font-weight: 500;
    }
    .loading-step .step-detail {
      font-size: 11px;
      color: var(--text3);
      margin-top: 2px;
    }
    .loading-step.active .step-detail {
      color: var(--accent);
    }
    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(74, 158, 255, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(74, 158, 255, 0); }
    }
    
    /* Progress section */
    .loading-progress-section {
      margin-bottom: 16px;
    }
    .loading-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .loading-progress-header .pct {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
    }
    .loading-progress-header .stats {
      font-size: 11px;
      color: var(--text3);
    }
    .loading-progress-track {
      height: 8px;
      background: var(--bg3);
      border-radius: 4px;
      overflow: hidden;
    }
    .loading-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #6ab0ff);
      border-radius: 4px;
      width: 0%;
      transition: width 0.4s ease-out;
      position: relative;
    }
    .loading-progress-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .loading-footer {
      text-align: center;
      font-size: 11px;
      color: var(--text3);
    }
    .loading-footer .tip {
      margin-top: 4px;
      font-style: italic;
    }
    
    /* === RIGHT COLUMN: OPTIONS === */
    .col-options {
      background: var(--bg2);
      border-left: 1px solid var(--border);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }
    
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
    }
    .card-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text3);
      margin-bottom: 10px;
      font-weight: 600;
    }
    .card select {
      width: 100%;
      padding: 10px 32px 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
    }
    .card select:hover { border-color: var(--text3); }
    .card select:focus { outline: none; border-color: var(--accent); }
    .card input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
    }
    .card input:focus { outline: none; border-color: var(--accent); }
    .card input::placeholder { color: var(--text3); }
    
    /* Card with sub-sections */
    .card-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .card-section:first-child {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }
    .card-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .card-row:last-child { margin-bottom: 0; }
    .card-row .field {
      flex: 1;
    }
    .card-row .field-label {
      font-size: 9px;
      color: var(--text3);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .card-row input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }
    .card-row input[type="color"] {
      width: 100%;
      height: 32px;
      padding: 2px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
    }
    .card-row select {
      width: 100%;
      padding: 8px 28px 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }
    
    /* Toggle row */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
    }
    .toggle-row .toggle-label {
      font-size: 12px;
      color: var(--text2);
    }
    .toggle-switch {
      position: relative;
      width: 36px;
      height: 20px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-switch .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: var(--bg3);
      border-radius: 20px;
      transition: 0.2s;
      border: 1px solid var(--border);
    }
    .toggle-switch .slider::before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 2px;
      bottom: 2px;
      background: var(--text2);
      border-radius: 50%;
      transition: 0.2s;
    }
    .toggle-switch input:checked + .slider { background: var(--accent); border-color: var(--accent); }
    .toggle-switch input:checked + .slider::before { transform: translateX(16px); background: #fff; }
    
    /* Info tooltip */
    .info-text {
      font-size: 10px;
      color: var(--text3);
      line-height: 1.4;
      margin-top: 8px;
      padding: 8px;
      background: var(--bg);
      border-radius: 6px;
    }
    
    /* Pill Toggle */
    .pill-toggle {
      display: flex;
      background: var(--bg);
      border-radius: 8px;
      padding: 4px;
      border: 1px solid var(--border);
    }
    .pill-toggle input { display: none; }
    .pill-toggle label {
      flex: 1;
      padding: 8px 12px;
      text-align: center;
      font-size: 12px;
      color: var(--text2);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .pill-toggle input:checked + label {
      background: var(--accent);
      color: #fff;
    }
    
    .card-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-primary:hover { background: #3d8ce8; }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary {
      background: var(--bg3);
      color: var(--text2);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover:not(:disabled) { background: var(--bg); color: var(--text); }
    .btn-secondary:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn-row {
      display: flex;
      gap: 8px;
    }
    .btn-row .btn { flex: 1; }
    
    /* Checkbox */
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text2);
      cursor: pointer;
    }
    .checkbox-row input { width: 16px; height: 16px; accent-color: var(--accent); }
    
    /* Slider */
    .slider-row {
      margin-top: 4px;
    }
    .slider-row .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text2);
      margin-bottom: 6px;
    }
    .slider-row input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }
    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
    }
    
    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
    }
    .modal.open { display: flex; }
    .modal-content {
      background: var(--bg2);
      border-radius: 16px;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      width: 100%;
      border: 1px solid var(--border);
    }
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 {
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 2px;
    }
    .modal-close {
      background: none;
      border: none;
      color: var(--text2);
      font-size: 24px;
      cursor: pointer;
    }
    .modal-close:hover { color: var(--text); }
    .modal-body { padding: 20px; }
    
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
    }
    .theme-card {
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
    }
    .theme-card:hover { border-color: var(--accent); transform: translateY(-2px); }
    .theme-card canvas { width: 100%; display: block; }
    .theme-card-info { padding: 10px; display: flex; justify-content: space-between; align-items: center; }
    .theme-card-name { font-size: 12px; font-weight: 500; }
    
    /* Batch Modal */
    .batch-input {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }
    .batch-options { display: flex; gap: 12px; margin: 16px 0; flex-wrap: wrap; }
    .batch-options select {
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
    }
    .batch-log {
      background: var(--bg);
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      max-height: 150px;
      overflow-y: auto;
      margin-top: 12px;
      color: var(--text2);
    }
    
    /* Responsive */
    @media (max-width: 1000px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr auto; }
      .col-cities, .col-options { border: none; border-bottom: 1px solid var(--border); }
    }
    
    /* Hidden helpers */
    #offscreen { display: none; }
  </style>
</head>
<body data-ui="dark">
<div class="app">
  <!-- Header -->
  <header class="header">
    <div class="logo-group">
      <div class="logo">MapToPoster</div>
      <div class="tagline">Beautiful city map posters in seconds</div>
    </div>
    <div class="header-right">
      <div class="theme-toggle">
        <button id="uiClassic">Classic</button>
        <button id="uiDark" class="active">Dark</button>
      </div>
    </div>
  </header>
  
  <!-- Left Column: Cities -->
  <div class="col-cities">
    <div class="col-header">
      <div class="col-title">Cities</div>
    </div>
    <div class="city-search">
      <input type="text" id="citySearch" placeholder="Search cities...">
      <div class="city-filters">
        <div class="custom-select">
          <select id="sortOrder">
            <option value="region">By Region</option>
            <option value="name">A → Z</option>
            <option value="name-desc">Z → A</option>
          </select>
        </div>
      </div>
    </div>
    <div class="city-count" id="cityCount">200+ cities</div>
    <div class="city-list" id="cityList"></div>
  </div>
  
  <!-- Center: Preview -->
  <div class="col-preview">
    <!-- Loading overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
      <div class="loading-card">
        <div class="loading-header">
          <div class="spinner"></div>
          <div class="title" id="loadingCity">Generating Map...</div>
        </div>
        
        <div class="loading-steps">
          <div class="loading-step" id="step1">
            <div class="step-icon">1</div>
            <div class="step-content">
              <div class="step-title">Resolving City Boundary</div>
              <div class="step-detail" id="step1Detail">Finding city limits...</div>
            </div>
          </div>
          <div class="loading-step" id="step2">
            <div class="step-icon">2</div>
            <div class="step-content">
              <div class="step-title">Fetching Street Data</div>
              <div class="step-detail" id="step2Detail">Waiting...</div>
            </div>
          </div>
          <div class="loading-step" id="step3">
            <div class="step-icon">3</div>
            <div class="step-content">
              <div class="step-title">Loading Water Bodies</div>
              <div class="step-detail" id="step3Detail">Waiting...</div>
            </div>
          </div>
          <div class="loading-step" id="step4">
            <div class="step-icon">4</div>
            <div class="step-content">
              <div class="step-title">Rendering Preview</div>
              <div class="step-detail" id="step4Detail">Waiting...</div>
            </div>
          </div>
        </div>
        
        <div class="loading-progress-section">
          <div class="loading-progress-header">
            <span class="pct" id="loadingPct">0%</span>
            <span class="stats" id="loadingStats"></span>
          </div>
          <div class="loading-progress-track">
            <div class="loading-progress-fill" id="loadingProgressBar"></div>
          </div>
        </div>
        
        <div class="loading-footer">
          <div id="loadingTime">Starting...</div>
          <div class="tip">Large cities may take 10-30 seconds</div>
        </div>
      </div>
    </div>
    
    <!-- Canvas Toolbar -->
    <div class="canvas-toolbar" id="canvasToolbar">
      <div class="toolbar-group">
        <button id="zoomOut" title="Zoom Out">−</button>
        <span class="zoom-val" id="zoomLevel">100%</span>
        <button id="zoomIn" title="Zoom In">+</button>
        <button id="zoomReset" title="Reset View">↺</button>
      </div>
      <div class="divider"></div>
      <div class="toolbar-group">
        <button id="gridToggle" title="Toggle Grid">⊞</button>
        <button id="snapToggle" title="Snap to Center" class="active">◎</button>
      </div>
      <div class="divider"></div>
      <div class="toolbar-group">
        <label>Size</label>
        <div class="pill-mini" id="sizeToggle">
          <input type="radio" name="size" id="size5x7" value="5x7" checked>
          <label for="size5x7">5×7"</label>
          <input type="radio" name="size" id="size8x10" value="8x10">
          <label for="size8x10">8×10"</label>
          <input type="radio" name="size" id="size11x14" value="11x14">
          <label for="size11x14">11×14"</label>
          <input type="radio" name="size" id="size16x20" value="16x20">
          <label for="size16x20">16×20"</label>
        </div>
      </div>
      <div class="toolbar-group">
        <label>Orient</label>
        <div class="pill-mini" id="orientToggle">
          <input type="radio" name="orient" id="orientPortrait" value="portrait" checked>
          <label for="orientPortrait">Portrait</label>
          <input type="radio" name="orient" id="orientLandscape" value="landscape">
          <label for="orientLandscape">Landscape</label>
        </div>
      </div>
    </div>
    
    <div class="canvas-wrapper" id="canvasWrapper">
      <canvas id="preview"></canvas>
      <div class="grid-overlay" id="gridOverlay">
        <div class="grid-lines"></div>
        <div class="center-h"></div>
        <div class="center-v"></div>
      </div>
      <div class="snap-indicator" id="snapIndicator">Centered</div>
    </div>
    <div class="status-bar" id="status">Select a city to get started</div>
    <div class="progress" id="progress"><div class="progress-bar" id="progressBar"></div></div>
  </div>
  
  <!-- Right Column: Options -->
  <div class="col-options">
    <div class="card">
      <div class="card-label">Map Theme</div>
      <select id="theme"></select>
    </div>
    
    <div class="card">
      <div class="card-label">Text Options</div>
      <div class="card-section">
        <div class="card-row">
          <div class="field" style="flex:2;">
            <div class="field-label">City Name</div>
            <input type="text" id="customCity" placeholder="Auto-detect">
          </div>
          <div class="field" style="flex:1;">
            <div class="field-label">Size</div>
            <input type="number" id="cityFontSize" value="48" min="24" max="96" step="2">
          </div>
        </div>
        <div class="card-row">
          <div class="field" style="flex:2;">
            <div class="field-label">Subtitle</div>
            <input type="text" id="customCountry" placeholder="Auto-detect">
          </div>
          <div class="field" style="flex:1;">
            <div class="field-label">Size</div>
            <input type="number" id="subtitleFontSize" value="18" min="10" max="36" step="1">
          </div>
        </div>
        <div class="card-row">
          <div class="field">
            <div class="field-label">Font</div>
            <select id="fontStyle">
              <option value="system-ui, sans-serif">Clean Sans</option>
              <option value="Georgia, serif">Classic Serif</option>
              <option value="'Courier New', monospace">Typewriter</option>
            </select>
          </div>
        </div>
      </div>
      <div class="card-section">
        <div class="toggle-row">
          <span class="toggle-label">Show Coordinates</span>
          <label class="toggle-switch">
            <input type="checkbox" id="showCoords" checked>
            <span class="slider"></span>
          </label>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Show Water Bodies</span>
          <label class="toggle-switch">
            <input type="checkbox" id="water" checked>
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>
    
    <div class="card" style="margin-top:auto;">
      <div class="card-label">Export</div>
      <div class="card-actions">
        <button class="btn btn-primary" id="generate">Generate Preview</button>
        <div class="btn-row">
          <button class="btn btn-secondary" id="download" disabled>PNG</button>
          <button class="btn btn-secondary" id="downloadSvg" disabled>SVG</button>
        </div>
        <div class="info-text">
          <strong>PNG</strong> — Raster image, best for printing and sharing. Fixed resolution at 300 DPI.<br>
          <strong>SVG</strong> — Vector format, infinitely scalable. Best for large prints or editing.
        </div>
        <div class="btn-row" style="margin-top:8px;">
          <button class="btn btn-secondary" id="compare" disabled>Compare Themes</button>
          <button class="btn btn-secondary" id="batch">Batch</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Hidden internal state -->
<div id="selected" style="display:none;"></div>

<!-- Compare Modal -->
<div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="compareTitle">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="compareTitle">COMPARE THEMES</h2>
      <button class="modal-close" id="modalClose" aria-label="Close">×</button>
    </div>
    <div class="modal-body">
      <div class="theme-grid" id="themeGrid"></div>
    </div>
  </div>
</div>

<!-- Batch Modal -->
<div class="modal" id="batchModal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="batchTitle">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="batchTitle">BATCH MODE</h2>
      <button class="modal-close" id="batchClose" aria-label="Close">×</button>
    </div>
    <div class="modal-body">
      <p style="margin-bottom:12px; color:var(--text2); font-size:13px;">Enter one city per line (e.g., "Paris, France")</p>
      <textarea class="batch-input" id="batchInput" placeholder="Paris, France&#10;Tokyo, Japan&#10;New York, USA"></textarea>
      <div class="batch-options">
        <select id="batchTheme"></select>
        <select id="batchSize">
          <option value="5x7-portrait">5×7" Portrait</option>
          <option value="5x7-landscape">5×7" Landscape</option>
          <option value="8x10-portrait">8×10" Portrait</option>
          <option value="8x10-landscape">8×10" Landscape</option>
          <option value="11x14-portrait">11×14" Portrait</option>
          <option value="11x14-landscape">11×14" Landscape</option>
          <option value="16x20-portrait">16×20" Portrait</option>
          <option value="16x20-landscape">16×20" Landscape</option>
        </select>
        <button class="btn btn-primary" id="batchStart">Start Batch</button>
      </div>
      <div class="progress" id="batchProgress"><div class="progress-bar" id="batchProgressBar"></div></div>
      <div id="batchStatus" style="font-size:12px; color:var(--text2); margin-top:8px;"></div>
      <div class="batch-log" id="batchLog"></div>
    </div>
  </div>
</div>

<canvas id="offscreen"></canvas>

<script src="cities.js"></script>
<script>
const THEMES = {
  noir: { name: "Noir", desc: "Classic dark", bg: "#0a0a0a", text: "#fff", water: "#151520", roads: ["#fff","#ccc","#999","#666","#444"] },
  parchment: { name: "Ancient Parchment", desc: "Fantasy map style", bg: "#d4c4a8", text: "#2a1f14", water: "#8b9a7d", roads: ["#2a1f14","#3d2e1f","#5a4632","#7a6652","#9a8672"] },
  hologram: { name: "Hologram", desc: "Sci-fi futuristic", bg: "#050510", text: "#0ff", water: "#001a1a", roads: ["#0ff","#0af","#08f","#06a","#035"] },
  neon: { name: "Neon City", desc: "Cyberpunk nights", bg: "#0a0012", text: "#f0f", water: "#0f0a1a", roads: ["#0ff","#f0f","#ff0","#f60","#609"] },
  comic: { name: "Comic Pop", desc: "Bold cartoon style", bg: "#fff", text: "#000", water: "#7ec8e3", roads: ["#000","#e63946","#f4a261","#2a9d8f","#264653"] },
  candy: { name: "Candy", desc: "Bright & playful", bg: "#fff5f5", text: "#d63384", water: "#a8e6cf", roads: ["#d63384","#ff6b6b","#feca57","#48dbfb","#a55eea"] },
  midnight: { name: "Midnight Blue", desc: "Deep ocean tones", bg: "#0d1b2a", text: "#e0e1dd", water: "#1b263b", roads: ["#ffd700","#e0e1dd","#778da9","#415a77","#1b263b"] },
  blueprint: { name: "Blueprint", desc: "Technical drafting", bg: "#0a2463", text: "#fff", water: "#061539", roads: ["#fff","#d4e4f7","#9db4ce","#6884a5","#3e5c76"] },
  sepia: { name: "Vintage Sepia", desc: "Old photograph", bg: "#f5f0e6", text: "#2c2c2c", water: "#d4c4a8", roads: ["#2c2c2c","#4a4a4a","#6a6a6a","#9a9a9a","#c0c0c0"] },
  forest: { name: "Enchanted Forest", desc: "Deep woodland", bg: "#0f1a0f", text: "#98d982", water: "#0a120a", roads: ["#98d982","#6ab04c","#4a8030","#2a5010","#1a3008"] },
  sunset: { name: "Sunset", desc: "Warm golden hour", bg: "#1a0a0a", text: "#ffd700", water: "#2d1f1f", roads: ["#ff6b35","#f7c59f","#efa48b","#d7816a","#bd4f6c"] },
  ice: { name: "Frozen", desc: "Arctic cold", bg: "#e8f4f8", text: "#1a3a4a", water: "#a8d4e6", roads: ["#1a3a4a","#2a5a7a","#4a8aaa","#7abacc","#aadaee"] }
};

const ROAD_TYPES = ['motorway','motorway_link','trunk','trunk_link','primary','primary_link','secondary','secondary_link','tertiary','tertiary_link','residential','living_street','unclassified'];
const SIZES = {
  '5x7': { portrait: [1500, 2100], landscape: [2100, 1500] },
  '8x10': { portrait: [2400, 3000], landscape: [3000, 2400] },
  '11x14': { portrait: [3300, 4200], landscape: [4200, 3300] },
  '16x20': { portrait: [4800, 6000], landscape: [6000, 4800] }
};
const BASE_WIDTHS = [2.5, 2, 1.5, 1, 0.5];
const FETCH_TIMEOUT_MS = 30000;
const OVERPASS_TIMEOUT_MS = 60000;
const PHOTON_TIMEOUT_MS = 15000;
const CACHE_TTL_MS = 10 * 60 * 1000;
const CACHE_MAX_ENTRIES = 20;
const DEFAULT_ROAD_WEIGHT = 1;
const DEFAULT_RADIUS = 10000;
const PREVIEW_SIMPLIFY_PX = 0.8;
const PREVIEW_MAX_W = 1200;
const PREVIEW_MAX_H = 1200;
const SVG_PRECISION = 1;
const PREVIEW_FAST_THRESHOLD = 25000;

let place = null, data = null, zoom = 1, panX = 0, panY = 0, currentCity = null;
let activeControllers = new Set();
const STREET_CACHE = new Map();
const WATER_CACHE = new Map();
const GEOCODE_CACHE = new Map();
let previewLayer = null;
let previewLayerKey = '';
let dataVersion = 0;

const $ = id => document.getElementById(id);

// DOM Elements
const selectedEl = $('selected');
const customCityEl = $('customCity'), customCountryEl = $('customCountry');
const themeEl = $('theme'), waterEl = $('water'), showCoordsEl = $('showCoords');
const fontStyleEl = $('fontStyle');
const genBtn = $('generate'), dlBtn = $('download'), dlSvgBtn = $('downloadSvg'), compareBtn = $('compare'), batchBtn = $('batch');
const statusEl = $('status'), progressEl = $('progress'), progressBar = $('progressBar');
const canvas = $('preview'), offscreen = $('offscreen');
const modal = $('modal'), modalClose = $('modalClose'), themeGrid = $('themeGrid');
const batchModal = $('batchModal'), batchClose = $('batchClose'), batchInput = $('batchInput');
const batchTheme = $('batchTheme'), batchSize = $('batchSize'), batchStart = $('batchStart');
const batchStatus = $('batchStatus'), batchProgress = $('batchProgress'), batchProgressBar = $('batchProgressBar'), batchLog = $('batchLog');
const uiClassic = $('uiClassic'), uiDark = $('uiDark');
const canvasToolbar = $('canvasToolbar'), zoomIn = $('zoomIn'), zoomOut = $('zoomOut'), zoomReset = $('zoomReset'), zoomLevel = $('zoomLevel');
const gridToggle = $('gridToggle'), gridOverlay = $('gridOverlay'), snapIndicator = $('snapIndicator'), snapToggle = $('snapToggle');
const loadingOverlay = $('loadingOverlay'), loadingProgressBar = $('loadingProgressBar');
const loadingCity = $('loadingCity'), loadingPct = $('loadingPct'), loadingStats = $('loadingStats'), loadingTime = $('loadingTime');
const step1 = $('step1'), step2 = $('step2'), step3 = $('step3'), step4 = $('step4');
const step1Detail = $('step1Detail'), step2Detail = $('step2Detail'), step3Detail = $('step3Detail'), step4Detail = $('step4Detail');
const cityFontSizeEl = $('cityFontSize'), subtitleFontSizeEl = $('subtitleFontSize');
const citySearchEl = $('citySearch'), sortOrder = $('sortOrder');
const cityListEl = $('cityList'), cityCountEl = $('cityCount');

// Region mapping
const REGIONS = {
  'North America': ['USA', 'United States', 'Canada', 'Mexico'],
  'South America': ['Brazil', 'Argentina', 'Colombia', 'Chile', 'Peru', 'Venezuela', 'Ecuador', 'Uruguay'],
  'Europe': ['UK', 'United Kingdom', 'France', 'Germany', 'Italy', 'Spain', 'Netherlands', 'Belgium', 'Switzerland', 'Austria', 'Portugal', 'Sweden', 'Norway', 'Denmark', 'Finland', 'Poland', 'Czech Republic', 'Greece', 'Ireland', 'Hungary', 'Romania'],
  'Asia': ['Japan', 'China', 'India', 'South Korea', 'Thailand', 'Vietnam', 'Singapore', 'Malaysia', 'Indonesia', 'Philippines', 'Taiwan', 'Hong Kong', 'UAE', 'Saudi Arabia', 'Israel', 'Turkey', 'Qatar', 'Pakistan', 'Bangladesh'],
  'Africa': ['South Africa', 'Egypt', 'Nigeria', 'Kenya', 'Morocco', 'Ethiopia', 'Ghana', 'Tanzania'],
  'Oceania': ['Australia', 'New Zealand']
};

const REGION_ORDER = ['North America', 'Europe', 'Asia', 'South America', 'Africa', 'Oceania', 'Other'];
let collapsedRegions = new Set();

function getRegion(country) {
  for (const [region, countries] of Object.entries(REGIONS)) {
    if (countries.some(c => country.includes(c) || c.includes(country))) return region;
  }
  return 'Other';
}

// === CITY LIST ===
function renderCityList() {
  if (!CITIES) return;
  const searchTerm = citySearchEl.value.toLowerCase();
  const sort = sortOrder.value;
  
  let cities = Object.entries(CITIES).map(([key, c]) => ({ ...c, key }));
  if (searchTerm) cities = cities.filter(c => c.name.toLowerCase().includes(searchTerm) || c.country.toLowerCase().includes(searchTerm));
  
  // Group by region or sort flat
  if (sort === 'region') {
    // Group cities by region
    const grouped = {};
    cities.forEach(c => {
      const region = getRegion(c.country);
      if (!grouped[region]) grouped[region] = [];
      grouped[region].push(c);
    });
    
    // Sort each group alphabetically
    Object.values(grouped).forEach(arr => arr.sort((a, b) => a.name.localeCompare(b.name)));
    
    // Build HTML with collapsible groups
    let html = '';
    let totalCount = 0;
    REGION_ORDER.forEach(region => {
      const regionCities = grouped[region];
      if (!regionCities || !regionCities.length) return;
      totalCount += regionCities.length;
      const isCollapsed = collapsedRegions.has(region);
      html += `
        <div class="region-group${isCollapsed ? ' collapsed' : ''}" data-region="${region}">
          <div class="region-header" role="button" tabindex="0" aria-expanded="${!isCollapsed}">
            <span class="region-name">${region}</span>
            <span class="region-count">${regionCities.length} <span class="chevron">▼</span></span>
          </div>
          <div class="region-cities">
            ${regionCities.map(c => `
              <div class="city-item" data-key="${c.key}" role="button" tabindex="0">
                <div class="name">${c.name}</div>
                <div class="country">${c.country}</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    });
    
    cityCountEl.textContent = `${totalCount} cities`;
    cityListEl.innerHTML = html;
    
    // Add region toggle handlers
    cityListEl.querySelectorAll('.region-header').forEach(header => {
      const toggle = (e) => {
        e.stopPropagation();
        const group = header.closest('.region-group');
        const region = group.dataset.region;
        group.classList.toggle('collapsed');
        if (group.classList.contains('collapsed')) collapsedRegions.add(region);
        else collapsedRegions.delete(region);
        header.setAttribute('aria-expanded', String(!group.classList.contains('collapsed')));
      };
      header.onclick = toggle;
      header.onkeydown = (e) => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          toggle(e);
        }
      };
    });
  } else {
    // Flat list sorted
    if (sort === 'name') cities.sort((a, b) => a.name.localeCompare(b.name));
    else if (sort === 'name-desc') cities.sort((a, b) => b.name.localeCompare(a.name));
    
    cityCountEl.textContent = `${cities.length} cities`;
    cityListEl.innerHTML = cities.map(c => `
      <div class="city-item" data-key="${c.key}" role="button" tabindex="0">
        <div class="name">${c.name}</div>
        <div class="country">${c.country}</div>
      </div>
    `).join('');
  }
  
  // Add city click handlers
  cityListEl.querySelectorAll('.city-item').forEach(item => {
    item.onclick = (e) => {
      e.stopPropagation();
      selectCity(item.dataset.key);
    };
    item.onkeydown = (e) => {
      if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        selectCity(item.dataset.key);
      }
    };
  });
  
  // Highlight current city
  if (currentCity) {
    const active = cityListEl.querySelector(`[data-key="${currentCity}"]`);
    if (active) {
      active.classList.add('active');
      // Expand parent region if collapsed
      const parentGroup = active.closest('.region-group');
      if (parentGroup && parentGroup.classList.contains('collapsed')) {
        parentGroup.classList.remove('collapsed');
        collapsedRegions.delete(parentGroup.dataset.region);
        const header = parentGroup.querySelector('.region-header');
        if (header) header.setAttribute('aria-expanded', 'true');
      }
    }
  }
}

function selectCity(key) {
  const city = CITIES[key];
  if (!city) return;
  
  currentCity = key;
  place = { lat: city.lat, lon: city.lon, osm_type: 'relation', osm_id: city.osm_id, name: city.name, address: { city: city.name, country: city.country } };
  selectedEl.textContent = `${city.name}, ${city.country}`;
  selectedEl.dataset.city = city.name;
  selectedEl.dataset.country = city.country;
  
  cityListEl.querySelectorAll('.city-item').forEach(el => el.classList.remove('active'));
  const active = cityListEl.querySelector(`[data-key="${key}"]`);
  if (active) active.classList.add('active');
  
  genBtn.click();
}

citySearchEl.oninput = renderCityList;
sortOrder.onchange = renderCityList;

// === GRID TOGGLE ===
let showGrid = false;
let snapEnabled = true;

gridToggle.onclick = () => {
  showGrid = !showGrid;
  gridOverlay.classList.toggle('visible', showGrid);
  gridToggle.classList.toggle('active', showGrid);
};

snapToggle.onclick = () => {
  snapEnabled = !snapEnabled;
  snapToggle.classList.toggle('active', snapEnabled);
};

// === UI THEME ===
uiClassic.onclick = () => { document.body.dataset.ui = 'classic'; uiClassic.classList.add('active'); uiDark.classList.remove('active'); localStorage.setItem('ui', 'classic'); };
uiDark.onclick = () => { document.body.dataset.ui = 'dark'; uiDark.classList.add('active'); uiClassic.classList.remove('active'); localStorage.setItem('ui', 'dark'); };
if (localStorage.getItem('ui') === 'classic') uiClassic.click();

themeEl.onchange = () => { invalidatePreviewLayer(); if (data) render(canvas, themeEl.value, true); };

// === UTILITIES ===
function status(msg, err, loading) {
  statusEl.innerHTML = (loading ? '<span class="spinner"></span>' : '') + msg;
  statusEl.className = 'status-bar' + (err ? ' error' : '') + (loading ? ' loading' : '');
}

function setProgress(pct) {
  if (pct === null) { progressEl.classList.remove('active'); return; }
  progressEl.classList.add('active');
  progressBar.style.width = pct + '%';
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

function abortActiveRequests() {
  activeControllers.forEach(c => c.abort());
  activeControllers.clear();
}

function cacheKey(areaId, lat, lon, radius) {
  const id = areaId ? `a${areaId}` : `r${lat.toFixed(4)}:${lon.toFixed(4)}:${radius}`;
  return id;
}

function cacheGet(map, key) {
  const entry = map.get(key);
  if (!entry) return null;
  if (Date.now() - entry.ts > CACHE_TTL_MS) { map.delete(key); return null; }
  return entry.value;
}

function cacheSet(map, key, value) {
  map.set(key, { value, ts: Date.now() });
  if (map.size <= CACHE_MAX_ENTRIES) return;
  let oldestKey = null;
  let oldestTs = Infinity;
  for (const [k, v] of map.entries()) {
    if (v.ts < oldestTs) { oldestTs = v.ts; oldestKey = k; }
  }
  if (oldestKey) map.delete(oldestKey);
}

function getSize() {
  const sizeVal = document.querySelector('input[name="size"]:checked').value;
  const orientVal = document.querySelector('input[name="orient"]:checked').value;
  const [w, h] = SIZES[sizeVal][orientVal];
  return { w, h, orient: orientVal, label: sizeVal };
}
</script>
<script>
// === FETCH DATA ===
async function fetchWithRetry(url, options, retries = 3, timeoutMs = FETCH_TIMEOUT_MS) {
  for (let i = 0; i < retries; i++) {
    let controller = new AbortController();
    let timeoutId = null;
    let didTimeout = false;
    let onAbort = null;
    
    try {
      if (options?.signal) {
        onAbort = () => controller.abort();
        if (options.signal.aborted) onAbort();
        else options.signal.addEventListener('abort', onAbort, { once: true });
      }
      
      timeoutId = setTimeout(() => { didTimeout = true; controller.abort(); }, timeoutMs);
      activeControllers.add(controller);
      
      const res = await fetch(url, { ...(options || {}), signal: controller.signal });
      if (res.ok) return res;
      if (res.status === 429 || res.status >= 500) { await delay((i + 1) * 2000); continue; }
      throw new Error(`HTTP ${res.status}`);
    } catch (e) {
      if (e?.name === 'AbortError') {
        const msg = didTimeout ? 'Request timed out' : 'Request canceled';
        throw new Error(msg);
      } else if (i === retries - 1) {
        throw e;
      }
      await delay((i + 1) * 2000);
    } finally {
      if (timeoutId) clearTimeout(timeoutId);
      activeControllers.delete(controller);
      if (options?.signal && onAbort) options.signal.removeEventListener('abort', onAbort);
    }
  }
}

async function fetchJsonWithRetry(url, options, retries = 3, timeoutMs = FETCH_TIMEOUT_MS) {
  const res = await fetchWithRetry(url, options, retries, timeoutMs);
  return await res.json();
}

async function fetchStreets(areaId, lat, lon, radius) {
  const types = ROAD_TYPES.join('|');
  const useArea = !!areaId;
  const streetQ = useArea
    ? `[out:json][timeout:180];area(${areaId})->.a;way(area.a)["highway"~"^(${types})$"];out geom;`
    : `[out:json][timeout:180];way["highway"~"^(${types})$"](around:${radius},${lat},${lon});out geom;`;
  
  const streetRes = await fetchWithRetry('https://overpass-api.de/api/interpreter', { method: 'POST', body: streetQ }, 3, OVERPASS_TIMEOUT_MS);
  return await streetRes.json();
}

async function fetchWater(areaId, lat, lon, radius) {
  if (!waterEl.checked) return { elements: [] };
  
  const useArea = !!areaId;
  const waterQ = useArea
    ? `[out:json][timeout:90];area(${areaId})->.a;relation(area.a)["natural"="water"]->.rels;(way(area.a)["natural"="water"];way(area.a)["waterway"~"river|canal|stream"];way(r.rels););out geom;`
    : `[out:json][timeout:90];relation(around:${radius},${lat},${lon})["natural"="water"]->.rels;(way["natural"="water"](around:${radius},${lat},${lon});way["waterway"~"river|canal|stream"](around:${radius},${lat},${lon});way(r.rels););out geom;`;
  
  try {
    const waterRes = await fetchWithRetry('https://overpass-api.de/api/interpreter', { method: 'POST', body: waterQ }, 3, OVERPASS_TIMEOUT_MS);
    return await waterRes.json();
  } catch (e) {
    console.warn('Water fetch failed', e);
    return { elements: [] };
  }
}

async function fetchStreetsCached(areaId, lat, lon, radius) {
  const key = cacheKey(areaId, lat, lon, radius);
  const cached = cacheGet(STREET_CACHE, key);
  if (cached) return { result: cached, fromCache: true };
  const result = await fetchStreets(areaId, lat, lon, radius);
  cacheSet(STREET_CACHE, key, result);
  return { result, fromCache: false };
}

async function fetchWaterCached(areaId, lat, lon, radius) {
  if (!waterEl.checked) return { result: { elements: [] }, fromCache: false };
  const key = cacheKey(areaId, lat, lon, radius);
  const cached = cacheGet(WATER_CACHE, key);
  if (cached) return { result: cached, fromCache: true };
  const result = await fetchWater(areaId, lat, lon, radius);
  cacheSet(WATER_CACHE, key, result);
  return { result, fromCache: false };
}

async function fetchGeocodeCached(cityName, countryName) {
  const key = `${cityName.toLowerCase()}|${countryName.toLowerCase()}`;
  const cached = cacheGet(GEOCODE_CACHE, key);
  if (cached) return cached;
  const data = await fetchJsonWithRetry(`https://photon.komoot.io/api/?q=${encodeURIComponent(cityName + ', ' + countryName)}&limit=1`, { method: 'GET' }, 2, PHOTON_TIMEOUT_MS);
  cacheSet(GEOCODE_CACHE, key, data);
  return data;
}

// Batch processing helper - uses fetchStreets/fetchWater with progress callbacks
async function fetchData(areaId, lat, lon, radius, onProgress) {
  status('Fetching street data...', false, true);
  onProgress?.(20);
  const streets = await fetchStreets(areaId, lat, lon, radius);
  onProgress?.(60);
  
  status('Fetching water bodies...', false, true);
  onProgress?.(70);
  const water = await fetchWater(areaId, lat, lon, radius);
  onProgress?.(85);
  
  onProgress?.(90);
  return { streets, water };
}

function calcBounds(streets, water) {
  let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
  let hasPoints = false;
  const process = els => els.forEach(el => {
    (el.geometry || []).forEach(p => {
      hasPoints = true;
      minLat = Math.min(minLat, p.lat); maxLat = Math.max(maxLat, p.lat);
      minLon = Math.min(minLon, p.lon); maxLon = Math.max(maxLon, p.lon);
    });
  });
  process(streets.elements || []);
  process(water.elements || []);
  if (!hasPoints || !Number.isFinite(minLat) || !Number.isFinite(minLon)) return null;
  const pad = 0.05;
  return { minLat: minLat - (maxLat-minLat)*pad, maxLat: maxLat + (maxLat-minLat)*pad, minLon: minLon - (maxLon-minLon)*pad, maxLon: maxLon + (maxLon-minLon)*pad };
}

function normalizeBounds(bounds, minSpan = 0.0005) {
  const latSpan = Math.max(bounds.maxLat - bounds.minLat, minSpan);
  const lonSpan = Math.max(bounds.maxLon - bounds.minLon, minSpan);
  const latC = (bounds.minLat + bounds.maxLat) / 2;
  const lonC = (bounds.minLon + bounds.maxLon) / 2;
  return { minLat: latC - latSpan / 2, maxLat: latC + latSpan / 2, minLon: lonC - lonSpan / 2, maxLon: lonC + lonSpan / 2 };
}

function fallbackBounds(lat, lon, radiusM) {
  const latDelta = radiusM / 111000;
  const lonDelta = radiusM / (111000 * Math.cos(lat * Math.PI / 180) || 1);
  return { minLat: lat - latDelta, maxLat: lat + latDelta, minLon: lon - lonDelta, maxLon: lon + lonDelta };
}

function escapeXml(text) {
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

function expandHex(hex) {
  return hex.length === 4 ? '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3] : hex;
}

function getDisplayNames() {
  const city = customCityEl.value.trim() || data?.city || '';
  const country = customCountryEl.value.trim() || data?.country || '';
  return { city, country };
}

function invalidatePreviewLayer() {
  previewLayer = null;
  previewLayerKey = '';
}

function computeLayout(size, scale) {
  const { w: fullW, h: fullH, orient } = size;
  const w = Math.round(fullW * scale), h = Math.round(fullH * scale);
  const margin = Math.min(w, h) * 0.05;
  const isLandscape = orient === 'landscape';
  const mapW = w - margin * 2;
  const mapH = isLandscape ? h * 0.68 : h * 0.72;
  const mapTop = margin;
  
  const b = data.bounds;
  const dataAspect = (b.maxLon - b.minLon) / (b.maxLat - b.minLat);
  const mapAspect = mapW / mapH;
  const adj = { ...b };
  
  if (dataAspect > mapAspect) {
    const latC = (b.minLat + b.maxLat) / 2, range = (b.maxLon - b.minLon) / mapAspect;
    adj.minLat = latC - range / 2; adj.maxLat = latC + range / 2;
  } else {
    const lonC = (b.minLon + b.maxLon) / 2, range = (b.maxLat - b.minLat) * mapAspect;
    adj.minLon = lonC - range / 2; adj.maxLon = lonC + range / 2;
  }
  
  const proj = (lat, lon) => [
    margin + ((lon - adj.minLon) / (adj.maxLon - adj.minLon)) * mapW,
    mapTop + ((adj.maxLat - lat) / (adj.maxLat - adj.minLat)) * mapH
  ];
  
  return { w, h, margin, mapW, mapH, mapTop, isLandscape, proj };
}

function drawGeometry(ctx, geom, proj, minDistSq) {
  if (!geom || geom.length < 2) return;
  let lastX = null;
  let lastY = null;
  const lastIndex = geom.length - 1;
  geom.forEach((p, i) => {
    const [x, y] = proj(p.lat, p.lon);
    if (lastX === null) {
      ctx.moveTo(x, y);
      lastX = x; lastY = y;
      return;
    }
    const dx = x - lastX;
    const dy = y - lastY;
    const isLast = i === lastIndex;
    if (!isLast && minDistSq > 0 && (dx * dx + dy * dy) < minDistSq) return;
    ctx.lineTo(x, y);
    lastX = x; lastY = y;
  });
}

function drawMapLayer(ctx, layout, theme, scale, roadWeight) {
  const { proj } = layout;
  const minDistSq = scale < 1 ? PREVIEW_SIMPLIFY_PX * PREVIEW_SIMPLIFY_PX : 0;
  const totalRoads = (data.streets.elements || []).length;
  const totalWater = (data.water?.elements || []).length;
  const fastPreview = scale < 1 && (totalRoads + totalWater) > PREVIEW_FAST_THRESHOLD;
  const skipWater = fastPreview;
  
  // Water
  if (!skipWater && waterEl.checked && data.water?.elements) {
    ctx.fillStyle = theme.water;
    ctx.strokeStyle = theme.water;
    ctx.lineWidth = 1.5 * scale * roadWeight;
    data.water.elements.forEach(el => {
      if (!el.geometry) return;
      ctx.beginPath();
      drawGeometry(ctx, el.geometry, proj, minDistSq);
      const g = el.geometry;
      (g[0].lat === g[g.length-1].lat && g[0].lon === g[g.length-1].lon) ? ctx.fill() : ctx.stroke();
    });
  }
  
  // Roads
  const groups = { motorway: [], primary: [], secondary: [], tertiary: [], residential: [] };
  (data.streets.elements || []).forEach(el => {
    if (el.type !== 'way' || !el.geometry) return;
    const hw = el.tags?.highway?.replace('_link', '') || '';
    if (hw === 'motorway' || hw === 'trunk') groups.motorway.push(el);
    else if (hw === 'primary') groups.primary.push(el);
    else if (hw === 'secondary') groups.secondary.push(el);
    else if (hw === 'tertiary') groups.tertiary.push(el);
    else if (!fastPreview) groups.residential.push(el);
  });
  
  const order = ['residential', 'tertiary', 'secondary', 'primary', 'motorway'];
  order.forEach((grp, i) => {
    const roads = groups[grp];
    if (!roads.length) return;
    ctx.strokeStyle = theme.roads[4 - i];
    ctx.lineWidth = BASE_WIDTHS[4 - i] * scale * roadWeight * (scale < 1 ? 1.3 : 1);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    roads.forEach(r => { drawGeometry(ctx, r.geometry, proj, minDistSq); });
    ctx.stroke();
  });
}

// === RENDER ===
function render(cvs, themeKey, isPreview, scaleOverride, sizeOverride, options) {
  if (!data) return;
  const size = sizeOverride || getSize();
  const theme = THEMES[themeKey];
  let scale = scaleOverride || (isPreview ? 0.35 : 1);
  const roadWeight = DEFAULT_ROAD_WEIGHT;
  const font = fontStyleEl?.value || 'system-ui, sans-serif';
  const showCoords = showCoordsEl?.checked !== false;
  const { city, country } = getDisplayNames();
  const ignorePanZoom = options?.ignorePanZoom === true;
  
  if (isPreview && !scaleOverride) {
    const { w: fullW, h: fullH } = size;
    const w = Math.round(fullW * scale);
    const h = Math.round(fullH * scale);
    const capScale = Math.min(PREVIEW_MAX_W / w, PREVIEW_MAX_H / h, 1);
    scale = scale * capScale;
  }
  
  const layout = computeLayout(size, scale);
  const { w, h, margin, mapW, mapH, mapTop, isLandscape } = layout;
  cvs.width = w; cvs.height = h;
  const ctx = cvs.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  
  ctx.fillStyle = theme.bg;
  ctx.fillRect(0, 0, w, h);
  
  if (isPreview) {
    const key = `${dataVersion}|${themeKey}|${size.label}|${size.orient}|${w}x${h}|${roadWeight}|${waterEl.checked ? 1 : 0}|${scale.toFixed(4)}`;
    if (!previewLayer || previewLayerKey !== key) {
      previewLayer = document.createElement('canvas');
      previewLayer.width = w;
      previewLayer.height = h;
      const pctx = previewLayer.getContext('2d');
      pctx.clearRect(0, 0, w, h);
      const totalFeatures = (data.streets.elements || []).length + (data.water?.elements || []).length;
      const fastPreview = scale < 1 && totalFeatures > PREVIEW_FAST_THRESHOLD;
      if (fastPreview) {
        status(`Large city detected (${totalFeatures.toLocaleString()} features). Using fast preview.`, false, true);
      }
      drawMapLayer(pctx, layout, theme, scale, roadWeight);
      previewLayerKey = key;
    }
    
    ctx.save();
    if (!ignorePanZoom && (zoom !== 1 || panX !== 0 || panY !== 0)) {
      ctx.translate(w/2 + panX, h/2 + panY);
      ctx.scale(zoom, zoom);
      ctx.translate(-w/2, -h/2);
    }
    ctx.drawImage(previewLayer, 0, 0);
    ctx.restore();
  } else {
    drawMapLayer(ctx, layout, theme, scale, roadWeight);
  }
  
  const bgColor = expandHex(theme.bg);
  
  // Fades
  if (!isPreview || zoom === 1) {
    const fadeH = h * 0.08;
    let grad = ctx.createLinearGradient(0, 0, 0, fadeH);
    grad.addColorStop(0, bgColor); grad.addColorStop(1, bgColor + '00');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, w, fadeH);
    
    grad = ctx.createLinearGradient(0, mapTop + mapH - fadeH, 0, mapTop + mapH + fadeH * 0.5);
    grad.addColorStop(0, bgColor + '00'); grad.addColorStop(1, bgColor);
    ctx.fillStyle = grad; ctx.fillRect(0, mapTop + mapH - fadeH, w, fadeH * 1.5);
  }
  
  // Text
  const textY = mapTop + mapH + margin * (isLandscape ? 0.6 : 0.8);
  ctx.textAlign = 'center';
  
  // Use custom font sizes from inputs
  const baseCitySize = parseInt(cityFontSizeEl?.value || 48);
  const baseSubtitleSize = parseInt(subtitleFontSizeEl?.value || 18);
  const citySize = Math.round(baseCitySize * scale * (isLandscape ? 0.85 : 1));
  ctx.font = `300 ${citySize}px ${font}`;
  ctx.fillStyle = theme.text;
  const cityUpper = city.toUpperCase();
  const spacing = 10 * scale;
  let tw = 0;
  for (const c of cityUpper) tw += ctx.measureText(c).width + spacing;
  tw -= spacing;
  let x = (w - tw) / 2;
  for (const c of cityUpper) { ctx.fillText(c, x + ctx.measureText(c).width / 2, textY); x += ctx.measureText(c).width + spacing; }
  
  const lineY = textY + citySize * 0.35;
  ctx.strokeStyle = theme.text + '40'; ctx.lineWidth = scale;
  ctx.beginPath(); ctx.moveTo(w/2 - 30*scale, lineY); ctx.lineTo(w/2 + 30*scale, lineY); ctx.stroke();
  
  const countrySize = Math.round(baseSubtitleSize * scale);
  ctx.font = `400 ${countrySize}px ${font}`;
  ctx.fillStyle = theme.text + 'cc';
  ctx.fillText(country.toUpperCase(), w/2, lineY + countrySize * 1.4);
  
  if (showCoords) {
    const coordSize = Math.round(12 * scale);
    ctx.font = `300 ${coordSize}px ${font}`;
    ctx.fillStyle = theme.text + '88';
    const lat = data.lat, lon = data.lon;
    const coords = `${Math.abs(lat).toFixed(4)}°${lat >= 0 ? 'N' : 'S'}, ${Math.abs(lon).toFixed(4)}°${lon >= 0 ? 'E' : 'W'}`;
    ctx.fillText(coords, w/2, lineY + countrySize * 1.4 + coordSize * 1.6);
  }
  
  // Draw map boundary indicator (only in preview mode)
  if (isPreview && !ignorePanZoom && zoom === 1 && panX === 0 && panY === 0) {
    ctx.strokeStyle = theme.text + '20';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(margin, mapTop, mapW, mapH);
    ctx.setLineDash([]);
  }
}

function renderSvg(themeKey, sizeOverride) {
  if (!data) return null;
  const size = sizeOverride || getSize();
  const { w, h, orient } = size;
  const theme = THEMES[themeKey];
  const roadWeight = parseFloat(roadWeightEl?.value || 1);
  const font = fontStyleEl?.value || 'system-ui, sans-serif';
  const showCoords = showCoordsEl?.checked !== false;
  const { city, country } = getDisplayNames();
  
  const margin = Math.min(w, h) * 0.05;
  const isLandscape = orient === 'landscape';
  const mapW = w - margin * 2;
  const mapH = isLandscape ? h * 0.68 : h * 0.72;
  const mapTop = margin;
  
  const b = data.bounds;
  const dataAspect = (b.maxLon - b.minLon) / (b.maxLat - b.minLat);
  const mapAspect = mapW / mapH;
  const adj = { ...b };
  
  if (dataAspect > mapAspect) {
    const latC = (b.minLat + b.maxLat) / 2, range = (b.maxLon - b.minLon) / mapAspect;
    adj.minLat = latC - range / 2; adj.maxLat = latC + range / 2;
  } else {
    const lonC = (b.minLon + b.maxLon) / 2, range = (b.maxLat - b.minLat) * mapAspect;
    adj.minLon = lonC - range / 2; adj.maxLon = lonC + range / 2;
  }
  
  const proj = (lat, lon) => [
    margin + ((lon - adj.minLon) / (adj.maxLon - adj.minLon)) * mapW,
    mapTop + ((adj.maxLat - lat) / (adj.maxLat - adj.minLat)) * mapH
  ];
  
  const fmt = n => Number.isFinite(n) ? n.toFixed(SVG_PRECISION) : '0';
  const pathFromGeom = (geom, closePath) => {
    if (!geom || !geom.length) return '';
    let d = '';
    geom.forEach((p, i) => {
      const [x, y] = proj(p.lat, p.lon);
      d += (i === 0 ? 'M' : 'L') + fmt(x) + ' ' + fmt(y);
    });
    if (closePath) d += 'Z';
    return d;
  };
  
  const waterFill = [];
  const waterStroke = [];
  if (waterEl.checked && data.water?.elements) {
    data.water.elements.forEach(el => {
      if (!el.geometry) return;
      const g = el.geometry;
      const isClosed = g[0].lat === g[g.length - 1].lat && g[0].lon === g[g.length - 1].lon;
      const d = pathFromGeom(g, isClosed);
      if (!d) return;
      if (isClosed) waterFill.push(d);
      else waterStroke.push(d);
    });
  }
  
  const groups = { motorway: [], primary: [], secondary: [], tertiary: [], residential: [] };
  (data.streets.elements || []).forEach(el => {
    if (el.type !== 'way' || !el.geometry) return;
    const hw = el.tags?.highway?.replace('_link', '') || '';
    if (hw === 'motorway' || hw === 'trunk') groups.motorway.push(el);
    else if (hw === 'primary') groups.primary.push(el);
    else if (hw === 'secondary') groups.secondary.push(el);
    else if (hw === 'tertiary') groups.tertiary.push(el);
    else groups.residential.push(el);
  });
  
  const roadOrder = ['residential', 'tertiary', 'secondary', 'primary', 'motorway'];
  const roadPaths = roadOrder.map(group => {
    let d = '';
    groups[group].forEach(r => {
      d += pathFromGeom(r.geometry, false);
    });
    return d;
  });
  
  const bgColor = expandHex(theme.bg);
  const textColor = expandHex(theme.text);
  const fadeH = h * 0.08;
  const textY = mapTop + mapH + margin * (isLandscape ? 0.6 : 0.8);
  const baseCitySize = parseInt(cityFontSizeEl?.value || 48);
  const baseSubtitleSize = parseInt(subtitleFontSizeEl?.value || 18);
  const citySize = Math.round(baseCitySize * (isLandscape ? 0.85 : 1));
  const countrySize = Math.round(baseSubtitleSize);
  const lineY = textY + citySize * 0.35;
  
  const cityText = escapeXml((city || '').toUpperCase());
  const countryText = escapeXml((country || '').toUpperCase());
  const coords = showCoords
    ? `${Math.abs(data.lat).toFixed(4)}°${data.lat >= 0 ? 'N' : 'S'}, ${Math.abs(data.lon).toFixed(4)}°${data.lon >= 0 ? 'E' : 'W'}`
    : '';
  
  const svg = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`,
    `<defs>`,
    `<linearGradient id="fadeTop" x1="0" y1="0" x2="0" y2="1">`,
    `<stop offset="0%" stop-color="${bgColor}" />`,
    `<stop offset="100%" stop-color="${bgColor}" stop-opacity="0" />`,
    `</linearGradient>`,
    `<linearGradient id="fadeBottom" x1="0" y1="0" x2="0" y2="1">`,
    `<stop offset="0%" stop-color="${bgColor}" stop-opacity="0" />`,
    `<stop offset="100%" stop-color="${bgColor}" />`,
    `</linearGradient>`,
    `</defs>`,
    `<rect width="100%" height="100%" fill="${bgColor}" />`,
    waterFill.length ? `<path d="${waterFill.join('')}" fill="${theme.water}" stroke="none" />` : '',
    waterStroke.length ? `<path d="${waterStroke.join('')}" fill="none" stroke="${theme.water}" stroke-width="${(1.5 * roadWeight).toFixed(2)}" stroke-linecap="round" stroke-linejoin="round" />` : '',
    roadPaths.map((d, i) => d
      ? `<path d="${d}" fill="none" stroke="${theme.roads[4 - i]}" stroke-width="${(BASE_WIDTHS[4 - i] * roadWeight).toFixed(2)}" stroke-linecap="round" stroke-linejoin="round" />`
      : ''
    ).join(''),
    `<rect x="0" y="0" width="${w}" height="${fadeH}" fill="url(#fadeTop)" />`,
    `<rect x="0" y="${mapTop + mapH - fadeH}" width="${w}" height="${fadeH * 1.5}" fill="url(#fadeBottom)" />`,
    `<text x="${(w / 2).toFixed(2)}" y="${textY.toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="${citySize}" font-weight="300" letter-spacing="10" fill="${textColor}">${cityText}</text>`,
    `<line x1="${(w / 2 - 30).toFixed(2)}" y1="${lineY.toFixed(2)}" x2="${(w / 2 + 30).toFixed(2)}" y2="${lineY.toFixed(2)}" stroke="${textColor}40" stroke-width="1" />`,
    `<text x="${(w / 2).toFixed(2)}" y="${(lineY + countrySize * 1.4).toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="${countrySize}" font-weight="400" fill="${textColor}cc">${countryText}</text>`,
    showCoords ? `<text x="${(w / 2).toFixed(2)}" y="${(lineY + countrySize * 1.4 + 12 * 1.6).toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="12" font-weight="300" fill="${textColor}88">${escapeXml(coords)}</text>` : '',
    `</svg>`
  ].filter(Boolean).join('');
  
  return svg;
}
</script>
<script>
// === LOADING UI HELPERS ===
let loadStartTime = 0;
let loadingInterval = null;

function resetLoadingUI() {
  [step1, step2, step3, step4].forEach(s => {
    s.classList.remove('active', 'complete');
    s.querySelector('.step-icon').textContent = s.id.replace('step', '');
  });
  step1Detail.textContent = 'Finding city limits...';
  step2Detail.textContent = 'Waiting...';
  step3Detail.textContent = 'Waiting...';
  step4Detail.textContent = 'Waiting...';
  loadingPct.textContent = '0%';
  loadingStats.textContent = '';
  loadingProgressBar.style.width = '0%';
}

function setStep(num, status, detail) {
  const stepEl = $('step' + num);
  const detailEl = $('step' + num + 'Detail');
  
  if (status === 'active') {
    stepEl.classList.add('active');
    stepEl.classList.remove('complete');
  } else if (status === 'complete') {
    stepEl.classList.remove('active');
    stepEl.classList.add('complete');
    stepEl.querySelector('.step-icon').textContent = '✓';
  }
  
  if (detail) detailEl.textContent = detail;
}

function updateLoadingProgress(pct, stats) {
  loadingPct.textContent = Math.round(pct) + '%';
  loadingProgressBar.style.width = pct + '%';
  if (stats) loadingStats.textContent = stats;
}

function updateLoadingTime() {
  const elapsed = Math.round((Date.now() - loadStartTime) / 1000);
  loadingTime.textContent = `Elapsed: ${elapsed}s`;
}

// === GENERATE ===
genBtn.onclick = async () => {
  if (!place) { status('Select a city first'); return; }
  
  abortActiveRequests();
  genBtn.disabled = true;
  dlBtn.disabled = true;
  dlSvgBtn.disabled = true;
  compareBtn.disabled = true;
  zoom = 1; panX = 0; panY = 0;
  
  // Show loading overlay
  loadingOverlay.classList.remove('hidden');
  resetLoadingUI();
  loadingCity.textContent = `Generating ${place.name || 'Map'}...`;
  loadStartTime = Date.now();
  loadingInterval = setInterval(updateLoadingTime, 1000);
  
  try {
    // Step 1: Resolve boundary
    setStep(1, 'active', 'Finding city limits...');
    updateLoadingProgress(5);
    status('Resolving city boundary...', false, true);
    setProgress(5);
    
    let areaId = null;
    if (place.osm_type === 'relation' && place.osm_id) {
      areaId = 3600000000 + place.osm_id;
      setStep(1, 'complete', `OSM relation ${place.osm_id}`);
    } else {
      setStep(1, 'complete', 'Using radius-based area');
    }
    updateLoadingProgress(10);
    
    const radius = DEFAULT_RADIUS;
    
    // Step 2: Fetch streets
    setStep(2, 'active', 'Connecting to Overpass API...');
    updateLoadingProgress(15);
    
    const streetFetch = await fetchStreetsCached(areaId, place.lat, place.lon, radius);
    const streetResult = streetFetch.result;
    const streetCount = streetResult.elements?.length || 0;
    setStep(2, 'complete', `${streetCount.toLocaleString()} roads loaded${streetFetch.fromCache ? ' (cached)' : ''}`);
    updateLoadingProgress(55, `${streetCount.toLocaleString()} roads`);
    setProgress(55);
    
    // Step 3: Fetch water
    setStep(3, 'active', 'Fetching rivers, lakes...');
    updateLoadingProgress(60);
    
    const waterFetch = await fetchWaterCached(areaId, place.lat, place.lon, radius);
    const waterResult = waterFetch.result;
    const waterCount = waterResult.elements?.length || 0;
    setStep(3, 'complete', `${waterCount.toLocaleString()} water features${waterFetch.fromCache ? ' (cached)' : ''}`);
    updateLoadingProgress(85, `${streetCount.toLocaleString()} roads, ${waterCount.toLocaleString()} water`);
    setProgress(85);
    
    // Step 4: Render
    setStep(4, 'active', 'Drawing map...');
    updateLoadingProgress(90);
    
    const emptyData = streetCount === 0 && waterCount === 0;
    let bounds = calcBounds({ elements: streetResult.elements }, { elements: waterResult.elements });
    if (!bounds) {
      bounds = fallbackBounds(place.lat, place.lon, radius);
      status('No data returned. Rendering fallback view.', false, true);
      setStep(4, 'active', 'Rendering fallback...');
    }
    bounds = normalizeBounds(bounds);
    data = {
      streets: { elements: streetResult.elements },
      water: { elements: waterResult.elements },
      bounds,
      lat: place.lat,
      lon: place.lon,
      city: selectedEl.dataset.city || place.name || '',
      country: selectedEl.dataset.country || place.address?.country || ''
    };
    dataVersion += 1;
    invalidatePreviewLayer();
    
    render(canvas, themeEl.value, true);
    setStep(4, 'complete', 'Preview ready');
    updateLoadingProgress(100);
    setProgress(100);
    
    // Brief pause to show completion
    await new Promise(r => setTimeout(r, 400));
    
    if (emptyData) status('No streets or water found. Showing fallback bounds.');
    else status(`${streetCount.toLocaleString()} roads${waterCount ? `, ${waterCount.toLocaleString()} water features` : ''}`);
    
    dlBtn.disabled = false;
    dlSvgBtn.disabled = false;
    compareBtn.disabled = false;
    canvasToolbar.classList.add('visible');
    
  } catch (e) {
    console.error(e);
    status('Error: ' + e.message, true);
  } finally {
    genBtn.disabled = false;
    clearInterval(loadingInterval);
    loadingOverlay.classList.add('hidden');
    setTimeout(() => setProgress(null), 500);
  }
};

// === DOWNLOAD ===
dlBtn.onclick = () => {
  if (!data) return;
  status('Generating full resolution...', false, true);
  const { city } = getDisplayNames();
  const size = getSize();
  
  offscreen.width = size.w;
  offscreen.height = size.h;
  render(offscreen, themeEl.value, false);
  
  offscreen.toBlob(blob => {
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = `${city.toLowerCase().replace(/\s+/g, '-')}-${size.label}-${size.orient}.png`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    status('Downloaded!');
  }, 'image/png');
};

dlSvgBtn.onclick = () => {
  if (!data) return;
  status('Generating SVG...', false, true);
  const { city } = getDisplayNames();
  const size = getSize();
  const svg = renderSvg(themeEl.value, size);
  if (!svg) { status('SVG export failed', true); return; }
  
  const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url;
  a.download = `${city.toLowerCase().replace(/\s+/g, '-')}-${size.label}-${size.orient}.svg`;
  a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  status('Downloaded!');
};

// === ZOOM ===
zoomIn.onclick = () => { zoom = Math.min(zoom * 1.2, 5); zoomLevel.textContent = Math.round(zoom * 100) + '%'; render(canvas, themeEl.value, true); };
zoomOut.onclick = () => { zoom = Math.max(zoom / 1.2, 0.5); zoomLevel.textContent = Math.round(zoom * 100) + '%'; render(canvas, themeEl.value, true); };
zoomReset.onclick = () => { zoom = 1; panX = 0; panY = 0; zoomLevel.textContent = '100%'; render(canvas, themeEl.value, true); };

let renderQueued = false;
function scheduleRender() {
  if (!data || renderQueued) return;
  renderQueued = true;
  requestAnimationFrame(() => {
    renderQueued = false;
    if (data) render(canvas, themeEl.value, true);
  });
}

let isPanning = false, lastX, lastY, snapTimeout;
const SNAP_THRESHOLD = 15;

function showSnap(msg) {
  snapIndicator.textContent = msg;
  snapIndicator.classList.add('visible');
  clearTimeout(snapTimeout);
  snapTimeout = setTimeout(() => snapIndicator.classList.remove('visible'), 800);
}

canvas.onmousedown = e => { isPanning = true; lastX = e.clientX; lastY = e.clientY; canvas.style.cursor = 'grabbing'; };
document.onmousemove = e => {
  if (!isPanning) return;
  panX += e.clientX - lastX;
  panY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  
  // Snap to center (if enabled)
  if (snapEnabled) {
    if (Math.abs(panX) < SNAP_THRESHOLD && Math.abs(panY) < SNAP_THRESHOLD) {
      if (panX !== 0 || panY !== 0) { panX = 0; panY = 0; showSnap('Centered'); }
    } else if (Math.abs(panX) < SNAP_THRESHOLD) {
      if (panX !== 0) { panX = 0; showSnap('Centered H'); }
    } else if (Math.abs(panY) < SNAP_THRESHOLD) {
      if (panY !== 0) { panY = 0; showSnap('Centered V'); }
    }
  }
  
  scheduleRender();
};
document.onmouseup = () => { isPanning = false; canvas.style.cursor = 'grab'; };
canvas.onwheel = e => { e.preventDefault(); const d = e.deltaY > 0 ? 0.9 : 1.1; zoom = Math.min(Math.max(zoom * d, 0.5), 5); zoomLevel.textContent = Math.round(zoom * 100) + '%'; scheduleRender(); };

// === COMPARE MODAL ===
let lastFocusedEl = null;
function getFocusable(el) {
  return Array.from(el.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'))
    .filter(node => !node.disabled && node.getClientRects().length > 0);
}

function trapFocus(modalEl, e) {
  if (e.key !== 'Tab') return;
  const focusable = getFocusable(modalEl);
  if (!focusable.length) return;
  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  if (e.shiftKey && document.activeElement === first) {
    e.preventDefault();
    last.focus();
  } else if (!e.shiftKey && document.activeElement === last) {
    e.preventDefault();
    first.focus();
  }
}

function openModal(modalEl) {
  lastFocusedEl = document.activeElement;
  modalEl.classList.add('open');
  modalEl.setAttribute('aria-hidden', 'false');
  const focusable = getFocusable(modalEl);
  if (focusable.length) focusable[0].focus();
  if (!modalEl._focusTrap) modalEl._focusTrap = e => trapFocus(modalEl, e);
  modalEl.addEventListener('keydown', modalEl._focusTrap);
}

function closeModal(modalEl) {
  modalEl.classList.remove('open');
  modalEl.setAttribute('aria-hidden', 'true');
  if (modalEl._focusTrap) modalEl.removeEventListener('keydown', modalEl._focusTrap);
  if (lastFocusedEl && typeof lastFocusedEl.focus === 'function') lastFocusedEl.focus();
}

compareBtn.onclick = () => {
  if (!data) return;
  openModal(modal);
  themeGrid.innerHTML = '';
  
  Object.entries(THEMES).forEach(([key, theme]) => {
    const card = document.createElement('div');
    card.className = 'theme-card';
    const cvs = document.createElement('canvas');
    render(cvs, key, true, 0.2, null, { ignorePanZoom: true });
    card.appendChild(cvs);
    const info = document.createElement('div');
    info.className = 'theme-card-info';
    info.innerHTML = `<span class="theme-card-name">${theme.name}</span><button class="btn btn-primary" style="padding:6px 12px; font-size:10px;">Select</button>`;
    info.querySelector('button').onclick = () => { themeEl.value = key; render(canvas, key, true); closeModal(modal); };
    card.appendChild(info);
    themeGrid.appendChild(card);
  });
};
modalClose.onclick = () => closeModal(modal);

// === BATCH MODAL ===
batchBtn.onclick = () => openModal(batchModal);
batchClose.onclick = () => closeModal(batchModal);

function appendBatchLog(text, color) {
  const line = document.createElement('div');
  line.textContent = text;
  if (color) line.style.color = color;
  batchLog.appendChild(line);
}

batchStart.onclick = async () => {
  const lines = batchInput.value.split('\n').map(l => l.trim()).filter(l => l && l.includes(','));
  if (!lines.length) { batchStatus.textContent = 'No valid cities'; return; }
  
  abortActiveRequests();
  batchStart.disabled = true;
  batchLog.textContent = '';
  batchProgress.classList.add('active');
  const results = [];
  
  for (let i = 0; i < lines.length; i++) {
    const [cityName, countryName] = lines[i].split(',').map(s => s.trim());
    batchStatus.textContent = `Processing ${i + 1}/${lines.length}: ${cityName}`;
    batchProgressBar.style.width = ((i + 1) / lines.length * 100) + '%';
    
    try {
      // Geocode
      const geoData = await fetchGeocodeCached(cityName, countryName);
      if (!geoData.features?.length) throw new Error('City not found');
      
      const feature = geoData.features[0];
      const [lon, lat] = feature.geometry.coordinates;
      const osmId = feature.properties.osm_id;
      const osmType = feature.properties.osm_type;
      
      let areaId = null;
      if (osmType === 'R' && osmId) areaId = 3600000000 + osmId;
      
      const batchRadius = DEFAULT_RADIUS;
      const streetFetch = await fetchStreetsCached(areaId, lat, lon, batchRadius);
      const waterFetch = await fetchWaterCached(areaId, lat, lon, batchRadius);
      const result = { streets: streetFetch.result, water: waterFetch.result };
      let bounds = calcBounds(result.streets, result.water);
      if (!bounds) bounds = fallbackBounds(lat, lon, batchRadius);
      bounds = normalizeBounds(bounds);
      
      const tempData = { streets: result.streets, water: result.water, bounds, lat, lon, city: cityName, country: countryName };
      const oldData = data;
      data = tempData;
      
      const [sizeVal, orientVal] = batchSize.value.split('-');
      const size = { w: SIZES[sizeVal][orientVal][0], h: SIZES[sizeVal][orientVal][1], orient: orientVal, label: sizeVal };
      
      offscreen.width = size.w;
      offscreen.height = size.h;
      render(offscreen, batchTheme.value, false, 1, size);
      
      const blob = await new Promise(r => offscreen.toBlob(r, 'image/png'));
      results.push({ name: `${cityName.toLowerCase().replace(/\s+/g, '-')}.png`, blob });
      appendBatchLog(`✓ ${cityName}`, '#4a9eff');
      
      data = oldData;
    } catch (e) {
      appendBatchLog(`✗ ${cityName}: ${e.message}`, '#e55');
    }
    
    if (i < lines.length - 1) await new Promise(r => setTimeout(r, 2000));
  }
  
  // Download ZIP
  if (results.length) {
    batchStatus.textContent = 'Creating ZIP...';
    const { default: JSZip } = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm');
    const zip = new JSZip();
    results.forEach(r => zip.file(r.name, r.blob));
    const content = await zip.generateAsync({ type: 'blob' });
    const a = document.createElement('a');
    const url = URL.createObjectURL(content);
    a.href = url;
    a.download = 'map-posters.zip';
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }
  
  batchStatus.textContent = `Done! ${results.length}/${lines.length} generated`;
  batchStart.disabled = false;
  batchProgress.classList.remove('active');
};

// === KEYBOARD ===
document.onkeydown = e => {
  if (e.key !== 'Escape') return;
  if (modal.classList.contains('open')) closeModal(modal);
  if (batchModal.classList.contains('open')) closeModal(batchModal);
};

// === OPTION CHANGES ===
document.querySelectorAll('[name="size"], [name="orient"]').forEach(el => { el.onchange = () => { if (data) render(canvas, themeEl.value, true); }; });
waterEl.onchange = () => { invalidatePreviewLayer(); if (data) render(canvas, themeEl.value, true); };
showCoordsEl.onchange = () => { if (data) render(canvas, themeEl.value, true); };
fontStyleEl.onchange = () => { if (data) render(canvas, themeEl.value, true); };
customCityEl.oninput = () => { if (data) render(canvas, themeEl.value, true); };
customCountryEl.oninput = () => { if (data) render(canvas, themeEl.value, true); };
cityFontSizeEl.oninput = () => { if (data) render(canvas, themeEl.value, true); };
subtitleFontSizeEl.oninput = () => { if (data) render(canvas, themeEl.value, true); };

// === INIT ===
window.addEventListener('load', () => {
  try {
    // Populate theme dropdown
    if (themeEl) {
      themeEl.innerHTML = Object.entries(THEMES).map(([key, t]) => 
        `<option value="${key}">${t.name} — ${t.desc}</option>`
      ).join('');
    }
    
    // Populate batch theme dropdown
    if (batchTheme && themeEl) {
      batchTheme.innerHTML = themeEl.innerHTML;
    }
    
    // Render city list
    if (typeof CITIES !== 'undefined') {
      renderCityList();
    } else {
      console.error('CITIES not loaded');
    }
    
    // Auto-load Austin
    setTimeout(() => {
      if (typeof selectCity === 'function') {
        selectCity('austin');
      }
    }, 200);
  } catch (e) {
    console.error('Init error:', e);
  }
});
</script>
</body>
</html>
