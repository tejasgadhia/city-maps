<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MapToPoster — City Map Poster Generator</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%234a9eff'/><path d='M50 20c-11 0-20 9-20 20 0 15 20 35 20 35s20-20 20-35c0-11-9-20-20-20zm0 28a8 8 0 1 1 0-16 8 8 0 0 1 0 16z' fill='white'/></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@300;400;500;600&family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #0a0a0a;
      --bg2: #141414;
      --bg3: #1e1e1e;
      --card: #161616;
      --border: #2a2a2a;
      --text: #e5e5e5;
      --text2: #888;
      --text3: #555;
      --accent: #4a9eff;
      --radius: 12px;
    }
    
    [data-ui="classic"] {
      --bg: #e8e4dc;
      --bg2: #f0ece4;
      --bg3: #f8f6f1;
      --card: #fff;
      --border: #d4cfc4;
      --text: #2c2416;
      --text2: #5a5347;
      --text3: #8a8478;
      --accent: #2d7a54;
    }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      transition: background 0.3s, color 0.3s;
    }
    
    /* === THREE COLUMN LAYOUT === */
    .app {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      grid-template-rows: auto 1fr;
      height: 100vh;
      gap: 0;
    }
    
    /* === HEADER === */
    .header {
      grid-column: 1 / -1;
      padding: 12px 20px;
      background: var(--bg2);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .logo-group {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    .logo {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    .tagline {
      font-size: 12px;
      color: var(--text3);
      font-weight: 400;
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .theme-toggle {
      display: flex;
      background: var(--bg3);
      border-radius: 8px;
      padding: 3px;
      border: 1px solid var(--border);
    }
    .theme-toggle button {
      padding: 6px 12px;
      border: none;
      background: transparent;
      color: var(--text3);
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }
    .theme-toggle button.active { background: var(--accent); color: #fff; }
    .theme-toggle button:hover:not(.active) { color: var(--text); }
    
    /* === LEFT COLUMN: CITIES === */
    .col-cities {
      background: var(--bg2);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .col-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }
    .col-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text3);
      font-weight: 600;
    }
    .city-search {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .city-search input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
    }
    .city-search input:focus { outline: none; border-color: var(--accent); }
    .city-search input::placeholder { color: var(--text3); }
    .city-search .quick-search {
      display: flex;
      gap: 6px;
    }
    .city-search .quick-search button {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: var(--bg3);
      color: var(--text2);
      border-radius: 8px;
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 100%;
      justify-content: center;
    }
    .city-search .quick-search button:hover { background: var(--bg); color: var(--text); }
    .city-filters {
      display: flex;
      gap: 6px;
    }
    .city-filters select {
      flex: 1;
      padding: 7px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text2);
      font-size: 11px;
      cursor: pointer;
    }
    .city-count {
      padding: 0 16px 8px;
      font-size: 11px;
      color: var(--text3);
    }
    .city-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 8px 8px;
    }
    
    /* Region Groups (Collapsible) */
    .region-group {
      margin-bottom: 4px;
    }
    .region-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg3);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
    }
    .region-header:hover { background: var(--border); }
    .region-header .region-name {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text2);
    }
    .region-header .region-count {
      font-size: 10px;
      color: var(--text3);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .region-header .chevron {
      transition: transform 0.2s;
      font-size: 10px;
    }
    .region-group.collapsed .chevron { transform: rotate(-90deg); }
    .region-group.collapsed .region-cities { display: none; }
    .region-cities {
      padding: 4px 0 4px 8px;
    }
    
    .city-item {
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      margin-bottom: 2px;
    }
    .city-item:focus-visible,
    .region-header:focus-visible,
    .btn:focus-visible,
    select:focus-visible,
    input:focus-visible,
    textarea:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .city-item:hover { background: var(--bg3); }
    .city-item.active { background: var(--accent); }
    .city-item .name { font-size: 13px; font-weight: 500; }
    .city-item .country { font-size: 11px; color: var(--text3); margin-top: 1px; }
    .city-item.active .name { color: #fff; }
    .city-item.active .country { color: rgba(255,255,255,0.7); }
    
    /* Custom Dropdown Styling */
    .custom-select {
      position: relative;
    }
    .custom-select select {
      appearance: none;
      -webkit-appearance: none;
      width: 100%;
      padding: 8px 28px 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .custom-select select:hover { border-color: var(--text3); }
    .custom-select select:focus { outline: none; border-color: var(--accent); }
    .custom-select::after {
      content: '▾';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--text3);
      font-size: 10px;
    }
    
    /* === CENTER: PREVIEW === */
    .col-preview {
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 20px;
    }
    .canvas-wrapper {
      position: relative;
      display: inline-block;
    }
    #preview {
      max-width: 100%;
      max-height: 100%;
      border-radius: 4px;
      border: 2px solid var(--border);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      cursor: grab;
    }
    #preview:active { cursor: grabbing; }
    
    /* Grid Overlay */
    .grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: none;
      border-radius: 4px;
      overflow: hidden;
      z-index: 5;
    }
    .grid-overlay.visible { display: block; }
    .grid-overlay .center-h,
    .grid-overlay .center-v {
      position: absolute;
      background: rgba(74, 158, 255, 0.6);
    }
    .grid-overlay .center-h {
      left: 0;
      right: 0;
      top: 50%;
      height: 1px;
      transform: translateY(-50%);
    }
    .grid-overlay .center-v {
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      transform: translateX(-50%);
    }
    .grid-overlay .grid-lines {
      position: absolute;
      inset: 0;
      background-image: 
        linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 10% 10%;
    }
    
    /* Snap indicator */
    .snap-indicator {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: #fff;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 10px;
      opacity: 0;
      transition: opacity 0.15s;
      pointer-events: none;
    }
    .snap-indicator.visible { opacity: 1; }
    
    /* Canvas toolbar */
    .canvas-toolbar {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      background: var(--card);
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 20;
      max-width: calc(100% - 32px);
    }
    .canvas-toolbar.visible { display: flex; }
    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .toolbar-group label {
      font-size: 10px;
      color: var(--text3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-right: 6px;
    }
    .canvas-toolbar button {
      min-width: 32px;
      height: 32px;
      border: none;
      background: var(--bg3);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.15s;
    }
    .canvas-toolbar button:hover { background: var(--accent); color: #fff; }
    .canvas-toolbar button.active { background: var(--accent); color: #fff; }
    .canvas-toolbar button::after {
      content: attr(data-label);
      font-size: 9px;
      letter-spacing: 0.4px;
      display: none;
    }
    .canvas-toolbar .divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }
    .canvas-toolbar span.zoom-val {
      font-size: 11px;
      color: var(--text2);
      min-width: 45px;
      text-align: center;
    }
    .canvas-toolbar .pill-mini {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      background: var(--bg);
      border-radius: 6px;
      padding: 2px;
      border: 1px solid var(--border);
    }
    .canvas-toolbar .pill-mini input { display: none; }
    .canvas-toolbar .pill-mini label {
      padding: 6px 10px;
      font-size: 11px;
      color: var(--text2);
      border-radius: 4px;
      cursor: pointer;
      margin: 0;
      text-transform: none;
      letter-spacing: 0;
    }
    .canvas-toolbar .pill-mini input:checked + label {
      background: var(--accent);
      color: #fff;
    }
    .status-bar {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card);
      padding: 10px 20px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 13px;
      color: var(--text2);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .boundary-debug {
      position: absolute;
      bottom: 58px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg2);
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 11px;
      color: var(--text3);
      display: none;
    }
    body.debug .boundary-debug { display: block; }
    .status-bar.loading {
      color: var(--accent);
      background: var(--bg2);
      border-color: var(--accent);
      font-weight: 500;
    }
    .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: var(--bg3);
      display: none;
    }
    .progress.active { display: block; }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #6ab0ff);
      width: 0%;
      transition: width 0.3s;
      box-shadow: 0 0 10px var(--accent);
    }

    .preview-hint {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      text-align: center;
      padding: 24px;
      color: var(--text2);
    }
    .preview-hint.hidden { display: none; }
    .preview-hint .hint-card {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 16px 20px;
      border-radius: 12px;
      max-width: 420px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.25);
    }
    .preview-hint .hint-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: var(--text3);
      margin-bottom: 8px;
    }
    .preview-hint .hint-steps {
      font-size: 13px;
      color: var(--text2);
      line-height: 1.5;
    }
    
    /* Loading overlay - comprehensive design */
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .loading-overlay.hidden { display: none; }
    
    .loading-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 32px 40px;
      min-width: 340px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    .loading-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 24px;
    }
    .loading-header .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .loading-header .title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Steps */
    .loading-steps {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }
    .loading-step {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .loading-step .step-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      background: var(--bg3);
      color: var(--text3);
      border: 2px solid var(--border);
      flex-shrink: 0;
      transition: all 0.3s;
    }
    .loading-step.active .step-icon {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .loading-step.complete .step-icon {
      background: #22c55e;
      border-color: #22c55e;
      color: #fff;
    }
    .loading-step .step-content {
      flex: 1;
    }
    .loading-step .step-title {
      font-size: 13px;
      color: var(--text3);
      transition: color 0.3s;
    }
    .loading-step.active .step-title,
    .loading-step.complete .step-title {
      color: var(--text);
      font-weight: 500;
    }
    .loading-step .step-detail {
      font-size: 11px;
      color: var(--text3);
      margin-top: 2px;
    }
    .loading-step.active .step-detail {
      color: var(--accent);
    }
    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(74, 158, 255, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(74, 158, 255, 0); }
    }
    
    /* Progress section */
    .loading-progress-section {
      margin-bottom: 16px;
    }
    .loading-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .loading-progress-header .pct {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
    }
    .loading-progress-header .stats {
      font-size: 11px;
      color: var(--text3);
    }
    .loading-progress-track {
      height: 8px;
      background: var(--bg3);
      border-radius: 4px;
      overflow: hidden;
    }
    .loading-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #6ab0ff);
      border-radius: 4px;
      width: 0%;
      transition: width 0.4s ease-out;
      position: relative;
    }
    .loading-progress-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .loading-footer {
      text-align: center;
      font-size: 11px;
      color: var(--text3);
    }
    .loading-footer .tip {
      margin-top: 4px;
      font-style: italic;
    }
    
    /* === RIGHT COLUMN: OPTIONS === */
    .col-options {
      background: var(--bg2);
      border-left: 1px solid var(--border);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }
    
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
    }
    .card-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text3);
      margin-bottom: 10px;
      font-weight: 600;
    }
    .card select {
      width: 100%;
      padding: 10px 32px 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
    }
    .card select:hover { border-color: var(--text3); }
    .card select:focus { outline: none; border-color: var(--accent); }
    .card input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
    }
    .card input:focus { outline: none; border-color: var(--accent); }
    .card input::placeholder { color: var(--text3); }
    
    /* Card with sub-sections */
    .card-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .card-section:first-child {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }
    .card-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .card-row:last-child { margin-bottom: 0; }
    .card-row .field {
      flex: 1;
    }
    .card-row .field-label {
      font-size: 9px;
      color: var(--text3);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .card-row input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }
    .card-row input[type="color"] {
      width: 100%;
      height: 32px;
      padding: 2px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
    }
    .card-row select {
      width: 100%;
      padding: 8px 28px 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }
    
    /* Toggle row */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
    }
    .toggle-row .toggle-label {
      font-size: 12px;
      color: var(--text2);
    }
    .toggle-switch {
      position: relative;
      width: 36px;
      height: 20px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-switch .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: var(--bg3);
      border-radius: 20px;
      transition: 0.2s;
      border: 1px solid var(--border);
    }
    .toggle-switch .slider::before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 2px;
      bottom: 2px;
      background: var(--text2);
      border-radius: 50%;
      transition: 0.2s;
    }
    .toggle-switch input:checked + .slider { background: var(--accent); border-color: var(--accent); }
    .toggle-switch input:checked + .slider::before { transform: translateX(16px); background: #fff; }
    
    /* Info tooltip */
    .info-text {
      font-size: 10px;
      color: var(--text3);
      line-height: 1.4;
      margin-top: 8px;
      padding: 8px;
      background: var(--bg);
      border-radius: 6px;
    }
    
    /* Pill Toggle */
    .pill-toggle {
      display: flex;
      background: var(--bg);
      border-radius: 8px;
      padding: 4px;
      border: 1px solid var(--border);
    }
    .pill-toggle input { display: none; }
    .pill-toggle label {
      flex: 1;
      padding: 8px 12px;
      text-align: center;
      font-size: 12px;
      color: var(--text2);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .pill-toggle input:checked + label {
      background: var(--accent);
      color: #fff;
    }
    
    .card-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-primary:hover { background: #3d8ce8; }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary {
      background: var(--bg3);
      color: var(--text2);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover:not(:disabled) { background: var(--bg); color: var(--text); }
    .btn-secondary:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn-row {
      display: flex;
      gap: 8px;
    }
    .btn-row .btn { flex: 1; }
    
    /* Checkbox */
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text2);
      cursor: pointer;
    }
    .checkbox-row input { width: 16px; height: 16px; accent-color: var(--accent); }
    
    /* Slider */
    .slider-row {
      margin-top: 4px;
    }
    .slider-row .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text2);
      margin-bottom: 6px;
    }
    .slider-row input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }
    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
    }
    
    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
    }
    .modal.open { display: flex; }
    .modal-content {
      background: var(--bg2);
      border-radius: 16px;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      width: 100%;
      border: 1px solid var(--border);
    }
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 {
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 2px;
    }
    .modal-close {
      background: none;
      border: none;
      color: var(--text2);
      font-size: 24px;
      cursor: pointer;
    }
    .modal-close:hover { color: var(--text); }
    .modal-body { padding: 20px; }
    
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
    }
    .theme-card {
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
    }
    .theme-card:hover { border-color: var(--accent); transform: translateY(-2px); }
    .theme-card canvas { width: 100%; display: block; }
    .theme-card-info { padding: 10px; display: flex; justify-content: space-between; align-items: center; }
    .theme-card-name { font-size: 12px; font-weight: 500; }
    
    /* Batch Modal */
    .batch-input {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }
    .batch-options { display: flex; gap: 12px; margin: 16px 0; flex-wrap: wrap; }
    .batch-options select {
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
    }
    .batch-log {
      background: var(--bg);
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      max-height: 150px;
      overflow-y: auto;
      margin-top: 12px;
      color: var(--text2);
    }

    /* Mobile Blocker */
    body.mobile-blocked { overflow: hidden; }
    .mobile-blocker {
      position: fixed;
      inset: 0;
      background: rgba(10,10,10,0.96);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .mobile-blocker.active { display: flex; }
    .mobile-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      max-width: 520px;
      text-align: left;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .mobile-card h2 {
      font-size: 16px;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    .mobile-card p {
      font-size: 13px;
      color: var(--text2);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .mobile-card .tip {
      font-size: 12px;
      color: var(--text3);
    }
    
    /* Responsive */
    @media (max-width: 1000px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr auto; }
      .col-cities, .col-options { border: none; border-bottom: 1px solid var(--border); }
      .canvas-toolbar button {
        height: auto;
        padding: 6px 10px;
      }
      .canvas-toolbar button::after { display: inline; }
    }
    
    /* Hidden helpers */
    #offscreen { display: none; }
  </style>
</head>
<body data-ui="dark">
<div class="mobile-blocker" id="mobileBlocker" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="mobile-card">
    <h2>Desktop Required</h2>
    <p>MapToPoster is built for desktop browsers where the canvas and export tools work reliably.</p>
    <p>Please open this page on a laptop or desktop (Chrome, Firefox, or Safari).</p>
    <p class="tip">If you're on a tablet, try switching to a desktop browser or enabling "Request Desktop Website."</p>
  </div>
</div>
<div class="app">
  <!-- Header -->
  <header class="header">
    <div class="logo-group">
      <div class="logo">MapToPoster</div>
      <div class="tagline">Beautiful city map posters in seconds</div>
    </div>
    <div class="header-right">
      <div class="theme-toggle">
        <button id="uiClassic">Classic</button>
        <button id="uiDark" class="active">Dark</button>
      </div>
    </div>
  </header>
  
  <!-- Left Column: Cities -->
  <div class="col-cities">
    <div class="col-header">
      <div class="col-title">Cities</div>
    </div>
    <div class="city-search">
      <input type="text" id="citySearch" placeholder="Filter listed cities...">
      <div class="quick-search">
        <button id="citySearchOpen" type="button">Search any city...</button>
      </div>
      <div class="city-filters">
        <div class="custom-select">
          <select id="sortOrder">
            <option value="region">By Region</option>
            <option value="name">A → Z</option>
            <option value="name-desc">Z → A</option>
          </select>
        </div>
      </div>
    </div>
    <div class="city-count" id="cityCount">200+ cities</div>
    <div class="city-list" id="cityList"></div>
  </div>
  
  <!-- Center: Preview -->
  <div class="col-preview">
    <!-- Loading overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
      <div class="loading-card">
        <div class="loading-header">
          <div class="spinner"></div>
          <div class="title" id="loadingCity">Generating Map...</div>
        </div>
        
        <div class="loading-steps">
          <div class="loading-step" id="step1">
            <div class="step-icon">1</div>
            <div class="step-content">
              <div class="step-title">Resolving City Boundary</div>
              <div class="step-detail" id="step1Detail">Finding city limits...</div>
            </div>
          </div>
          <div class="loading-step" id="step2">
            <div class="step-icon">2</div>
            <div class="step-content">
              <div class="step-title">Fetching Street Data</div>
              <div class="step-detail" id="step2Detail">Waiting...</div>
            </div>
          </div>
          <div class="loading-step" id="step3">
            <div class="step-icon">3</div>
            <div class="step-content">
              <div class="step-title">Loading Water Bodies</div>
              <div class="step-detail" id="step3Detail">Waiting...</div>
            </div>
          </div>
          <div class="loading-step" id="step4">
            <div class="step-icon">4</div>
            <div class="step-content">
              <div class="step-title">Rendering Preview</div>
              <div class="step-detail" id="step4Detail">Waiting...</div>
            </div>
          </div>
        </div>
        
        <div class="loading-progress-section">
          <div class="loading-progress-header">
            <span class="pct" id="loadingPct">0%</span>
            <span class="stats" id="loadingStats"></span>
          </div>
          <div class="loading-progress-track">
            <div class="loading-progress-fill" id="loadingProgressBar"></div>
          </div>
        </div>
        
        <div class="loading-footer">
          <div id="loadingTime">Starting...</div>
          <div class="tip">Large cities may take 10-30 seconds</div>
        </div>
      </div>
    </div>
    
    <!-- Canvas Toolbar -->
    <div class="canvas-toolbar" id="canvasToolbar">
      <div class="toolbar-group">
        <button id="zoomOut" title="Zoom Out" data-label="Zoom Out">−</button>
        <span class="zoom-val" id="zoomLevel">100%</span>
        <button id="zoomIn" title="Zoom In" data-label="Zoom In">+</button>
        <button id="zoomReset" title="Reset View" data-label="Reset">↺</button>
      </div>
      <div class="divider"></div>
      <div class="toolbar-group">
        <button id="gridToggle" title="Toggle Grid" data-label="Grid">⊞</button>
        <button id="snapToggle" title="Snap to Center" data-label="Snap" class="active">◎</button>
      </div>
      <div class="divider"></div>
      <div class="toolbar-group">
        <button id="textMoveToggle" title="Move Text" data-label="Move Text">T</button>
        <button id="textReset" title="Reset Text Position" data-label="Reset Text">↺</button>
      </div>
    </div>
    
    <div class="canvas-wrapper" id="canvasWrapper">
      <canvas id="preview"></canvas>
      <div class="grid-overlay" id="gridOverlay">
        <div class="grid-lines"></div>
        <div class="center-h"></div>
        <div class="center-v"></div>
      </div>
      <div class="snap-indicator" id="snapIndicator">Centered</div>
    </div>
    <div class="preview-hint" id="previewHint">
      <div class="hint-card">
        <div class="hint-title">Create a Poster in 4 Steps</div>
        <div class="hint-steps">1. Pick a city on the left<br>2. Choose a theme and size<br>3. Preview updates automatically<br>4. Download PNG or SVG</div>
      </div>
    </div>
    <div class="boundary-debug" id="boundaryDebug"></div>
    <div class="status-bar" id="status">Select a city to get started</div>
    <div class="progress" id="progress"><div class="progress-bar" id="progressBar"></div></div>
  </div>
  
  <!-- Right Column: Options -->
  <div class="col-options">
    <div class="card">
      <div class="card-label">Map Theme</div>
      <select id="theme"></select>
    </div>

    <div class="card">
      <div class="card-label">Map Controls</div>
      <div class="card-row">
        <div class="field">
          <div class="field-label">Density</div>
          <select id="radiusPreset">
            <option value="tight">Tight</option>
            <option value="standard" selected>Standard</option>
            <option value="wide">Wide</option>
          </select>
        </div>
      </div>
      <div class="info-text" style="margin-top:6px;">
        Adjust how wide the map area is when boundaries are missing or too large.
      </div>
    </div>
    
    <div class="card">
      <div class="card-label">Text Options</div>
      <div class="card-section">
        <div class="card-row">
          <div class="field" style="flex:2;">
            <div class="field-label">Title</div>
            <input type="text" id="customCity" placeholder="Auto-detect">
          </div>
          <div class="field" style="flex:1;">
            <div class="field-label">Size</div>
            <input type="number" id="cityFontSize" value="48" min="24" max="96" step="2">
          </div>
        </div>
        <div class="card-row">
          <div class="field" style="flex:2;">
            <div class="field-label">Subtitle (e.g., Country)</div>
            <input type="text" id="customCountry" placeholder="Auto-detect">
          </div>
          <div class="field" style="flex:1;">
            <div class="field-label">Size</div>
            <input type="number" id="subtitleFontSize" value="18" min="10" max="36" step="1">
          </div>
        </div>
        <div class="card-row">
          <div class="field">
            <div class="field-label">Font</div>
            <select id="fontStyle">
              <option value="'Sora', system-ui, sans-serif">Sora Sans</option>
              <option value="'Cormorant Garamond', serif">Cormorant Serif</option>
              <option value="'IBM Plex Mono', 'Courier New', monospace">Plex Mono</option>
            </select>
          </div>
        </div>
        <div class="card-row">
          <div class="field">
            <div class="field-label">City Weight</div>
            <select id="cityWeight">
              <option value="300">Light</option>
              <option value="400">Regular</option>
              <option value="500">Medium</option>
              <option value="600">Semibold</option>
              <option value="700">Bold</option>
            </select>
          </div>
          <div class="field">
            <div class="field-label">Subtitle Weight</div>
            <select id="subtitleWeight">
              <option value="300">Light</option>
              <option value="400" selected>Regular</option>
              <option value="500">Medium</option>
              <option value="600">Semibold</option>
            </select>
          </div>
        </div>
        <div class="slider-row">
          <div class="slider-label">
            <span>Letter Spacing</span>
            <span id="citySpacingVal">10px</span>
          </div>
          <input type="range" id="citySpacing" min="2" max="24" step="1" value="10">
        </div>
        <div class="card-row">
          <div class="field">
            <div class="field-label">Separator</div>
            <select id="separatorStyle">
              <option value="line">Line</option>
              <option value="dots">Dots</option>
              <option value="none">None</option>
            </select>
          </div>
        </div>
      </div>
      <div class="card-section">
        <div class="toggle-row">
          <span class="toggle-label">Show Coordinates</span>
          <label class="toggle-switch">
            <input type="checkbox" id="showCoords" checked>
            <span class="slider"></span>
          </label>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Show Water Bodies</span>
          <label class="toggle-switch">
            <input type="checkbox" id="water" checked>
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>
    
    <div class="card" style="margin-top:auto;">
      <div class="card-label">Export</div>
      <div class="card-section">
        <div class="card-row">
          <div class="field">
            <div class="field-label">Poster Size</div>
            <select id="sizeSelect">
              <option value="5x7">5×7"</option>
              <option value="8x10">8×10"</option>
              <option value="11x14">11×14"</option>
              <option value="16x20">16×20"</option>
            </select>
          </div>
          <div class="field">
            <div class="field-label">Orientation</div>
            <select id="orientSelect">
              <option value="portrait">Portrait</option>
              <option value="landscape">Landscape</option>
            </select>
          </div>
        </div>
      </div>
      <div class="card-section">
        <div class="toggle-row">
          <span class="toggle-label">Include Bleed (0.125")</span>
          <label class="toggle-switch">
            <input type="checkbox" id="bleedToggle">
            <span class="slider"></span>
          </label>
        </div>
        <div class="info-text" style="margin-top:6px;">
          Adds extra margin for print trimming while keeping content safe.
        </div>
      </div>
      <div class="card-actions">
        <button class="btn btn-primary" id="generate">Regenerate Preview</button>
        <div class="btn-row">
          <button class="btn btn-secondary" id="download" disabled>PNG</button>
          <button class="btn btn-secondary" id="downloadSvg" disabled>SVG</button>
        </div>
        <div class="info-text">
          <strong>PNG</strong> — Raster image, best for printing and sharing. Fixed resolution at 300 DPI.<br>
          <strong>SVG</strong> — Vector format, infinitely scalable. Best for large prints or editing.
        </div>
        <div class="btn-row" style="margin-top:8px;">
          <button class="btn btn-secondary" id="compare" disabled>Compare Themes</button>
          <button class="btn btn-secondary" id="batch">Batch</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Hidden internal state -->
<div id="selected" style="display:none;"></div>

<!-- Search Modal -->
<div class="modal" id="searchModal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="searchTitle">
  <div class="modal-content" style="max-width:520px;">
    <div class="modal-header">
      <h2 id="searchTitle">SEARCH CITY</h2>
      <button class="modal-close" id="searchClose" aria-label="Close">×</button>
    </div>
    <div class="modal-body">
      <p style="margin-bottom:12px; color:var(--text2); font-size:13px;">Search any city (e.g., "Paris, France")</p>
      <input type="text" id="cityQuickSearch" placeholder="Search any city..." style="width:100%; padding:10px 12px; margin-bottom:12px; background:var(--bg); border:1px solid var(--border); border-radius:8px; color:var(--text); font-size:13px;">
      <button class="btn btn-primary" id="cityQuickBtn" type="button" style="width:100%;">Find</button>
    </div>
  </div>
</div>

<!-- Compare Modal -->
<div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="compareTitle">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="compareTitle">COMPARE THEMES</h2>
      <button class="modal-close" id="modalClose" aria-label="Close">×</button>
    </div>
    <div class="modal-body">
      <div class="theme-grid" id="themeGrid"></div>
    </div>
  </div>
</div>

<!-- Batch Modal -->
<div class="modal" id="batchModal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="batchTitle">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="batchTitle">BATCH MODE</h2>
      <button class="modal-close" id="batchClose" aria-label="Close">×</button>
    </div>
    <div class="modal-body">
      <p style="margin-bottom:12px; color:var(--text2); font-size:13px;">Enter one city per line (e.g., "Paris, France")</p>
      <textarea class="batch-input" id="batchInput" placeholder="Paris, France&#10;Tokyo, Japan&#10;New York, USA"></textarea>
      <div class="batch-options">
        <select id="batchTheme"></select>
        <select id="batchSize">
          <option value="5x7-portrait">5×7" Portrait</option>
          <option value="5x7-landscape">5×7" Landscape</option>
          <option value="8x10-portrait">8×10" Portrait</option>
          <option value="8x10-landscape">8×10" Landscape</option>
          <option value="11x14-portrait">11×14" Portrait</option>
          <option value="11x14-landscape">11×14" Landscape</option>
          <option value="16x20-portrait">16×20" Portrait</option>
          <option value="16x20-landscape">16×20" Landscape</option>
        </select>
        <button class="btn btn-primary" id="batchStart">Start Batch</button>
      </div>
      <div class="progress" id="batchProgress"><div class="progress-bar" id="batchProgressBar"></div></div>
      <div id="batchStatus" style="font-size:12px; color:var(--text2); margin-top:8px;"></div>
      <div class="batch-log" id="batchLog"></div>
    </div>
  </div>
</div>

<canvas id="offscreen"></canvas>

<script src="cities.js"></script>
<script>
const THEMES = {
  noir: { name: "Noir", desc: "Classic dark", bg: "#0a0a0a", text: "#fff", water: "#151520", roads: ["#fff","#ccc","#999","#666","#444"] },
  parchment: { name: "Ancient Parchment", desc: "Fantasy map style", bg: "#d4c4a8", text: "#2a1f14", water: "#8b9a7d", roads: ["#2a1f14","#3d2e1f","#5a4632","#7a6652","#9a8672"] },
  hologram: { name: "Hologram", desc: "Sci-fi futuristic", bg: "#050510", text: "#0ff", water: "#001a1a", roads: ["#0ff","#0af","#08f","#06a","#035"] },
  neon: { name: "Neon City", desc: "Cyberpunk nights", bg: "#0a0012", text: "#f0f", water: "#0f0a1a", roads: ["#0ff","#f0f","#ff0","#f60","#609"] },
  comic: { name: "Comic Pop", desc: "Bold cartoon style", bg: "#fff", text: "#000", water: "#7ec8e3", roads: ["#000","#e63946","#f4a261","#2a9d8f","#264653"] },
  candy: { name: "Candy", desc: "Bright & playful", bg: "#fff5f5", text: "#d63384", water: "#a8e6cf", roads: ["#d63384","#ff6b6b","#feca57","#48dbfb","#a55eea"] },
  midnight: { name: "Midnight Blue", desc: "Deep ocean tones", bg: "#0d1b2a", text: "#e0e1dd", water: "#1b263b", roads: ["#ffd700","#e0e1dd","#778da9","#415a77","#1b263b"] },
  blueprint: { name: "Blueprint", desc: "Technical drafting", bg: "#0a2463", text: "#fff", water: "#061539", roads: ["#fff","#d4e4f7","#9db4ce","#6884a5","#3e5c76"] },
  sepia: { name: "Vintage Sepia", desc: "Old photograph", bg: "#f5f0e6", text: "#2c2c2c", water: "#d4c4a8", roads: ["#2c2c2c","#4a4a4a","#6a6a6a","#9a9a9a","#c0c0c0"] },
  forest: { name: "Enchanted Forest", desc: "Deep woodland", bg: "#0f1a0f", text: "#98d982", water: "#0a120a", roads: ["#98d982","#6ab04c","#4a8030","#2a5010","#1a3008"] },
  sunset: { name: "Sunset", desc: "Warm golden hour", bg: "#1a0a0a", text: "#ffd700", water: "#2d1f1f", roads: ["#ff6b35","#f7c59f","#efa48b","#d7816a","#bd4f6c"] },
  ice: { name: "Frozen", desc: "Arctic cold", bg: "#e8f4f8", text: "#1a3a4a", water: "#a8d4e6", roads: ["#1a3a4a","#2a5a7a","#4a8aaa","#7abacc","#aadaee"] }
};

const ROAD_TYPES = ['motorway','motorway_link','trunk','trunk_link','primary','primary_link','secondary','secondary_link','tertiary','tertiary_link','residential','living_street','unclassified'];
const SIZES = {
  '5x7': { portrait: [1500, 2100], landscape: [2100, 1500] },
  '8x10': { portrait: [2400, 3000], landscape: [3000, 2400] },
  '11x14': { portrait: [3300, 4200], landscape: [4200, 3300] },
  '16x20': { portrait: [4800, 6000], landscape: [6000, 4800] }
};
const RADIUS_PRESETS = { tight: 0.7, standard: 1, wide: 1.4 };
const EXPORT_DPI = 300;
const BLEED_IN = 0.125;
const BLEED_PX = Math.round(EXPORT_DPI * BLEED_IN);
const BASE_WIDTHS = [2.5, 2, 1.5, 1, 0.5];
const FETCH_TIMEOUT_MS = 30000;
const OVERPASS_TIMEOUT_MS = 60000;
const PHOTON_TIMEOUT_MS = 15000;
const CACHE_TTL_MS = 10 * 60 * 1000;
const CACHE_MAX_ENTRIES = 20;
const DEFAULT_ROAD_WEIGHT = 1;
const DEFAULT_RADIUS = 10000;
const MAX_RADIUS = 60000;
const PREVIEW_SIMPLIFY_PX = 0.8;
const PREVIEW_MAX_W = 1200;
const PREVIEW_MAX_H = 1200;
const SVG_PRECISION = 1;
const PREVIEW_FAST_THRESHOLD = 25000;
const PREVIEW_CHUNK_SIZE = 400;
const BATCH_MAX_PARALLEL = 2;
const BATCH_MAX_RETRIES = 2;
const OVERPASS_ENDPOINTS = [
  'https://overpass-api.de/api/interpreter',
  'https://overpass.kumi.systems/api/interpreter',
  'https://overpass.nchc.org.tw/api/interpreter'
];
const STATE_VERSION = 1;
const STATE_STORAGE_KEY = 'maptoposter_state_v1';
const URL_STATE_PARAM = 's';

let place = null, data = null, zoom = 1, panX = 0, panY = 0, currentCity = null;
let previewRender = null;
let lastFetch = null;
let tempCityKey = null;
let activeControllers = new Set();
const STREET_CACHE = new Map();
const WATER_CACHE = new Map();
const GEOCODE_CACHE = new Map();
const BOUNDARY_CACHE = new Map();
const BOUNDARY_BOUNDS_CACHE = new Map();
let previewLayer = null;
let previewLayerKey = '';
let dataVersion = 0;
let previewProjCache = null;
let previewProjKey = '';
let textOffsetX = 0, textOffsetY = 0;
let textMoveEnabled = false;
let lastTextBounds = null;
let isTextDragging = false;
let fitQueued = false;
let renderQueue = Promise.resolve();
let applyingState = false;
let pendingViewState = null;
let stateSaveTimer = null;

const $ = id => document.getElementById(id);

// DOM Elements
const selectedEl = $('selected');
const customCityEl = $('customCity'), customCountryEl = $('customCountry');
const themeEl = $('theme'), waterEl = $('water'), showCoordsEl = $('showCoords');
const fontStyleEl = $('fontStyle');
const genBtn = $('generate'), dlBtn = $('download'), dlSvgBtn = $('downloadSvg'), compareBtn = $('compare'), batchBtn = $('batch');
const statusEl = $('status'), boundaryDebugEl = $('boundaryDebug'), progressEl = $('progress'), progressBar = $('progressBar');
const previewHint = $('previewHint');
const canvas = $('preview'), offscreen = $('offscreen');
const modal = $('modal'), modalClose = $('modalClose'), themeGrid = $('themeGrid');
const batchModal = $('batchModal'), batchClose = $('batchClose'), batchInput = $('batchInput');
const batchTheme = $('batchTheme'), batchSize = $('batchSize'), batchStart = $('batchStart');
const batchStatus = $('batchStatus'), batchProgress = $('batchProgress'), batchProgressBar = $('batchProgressBar'), batchLog = $('batchLog');
const uiClassic = $('uiClassic'), uiDark = $('uiDark');
const canvasToolbar = $('canvasToolbar'), zoomIn = $('zoomIn'), zoomOut = $('zoomOut'), zoomReset = $('zoomReset'), zoomLevel = $('zoomLevel');
const gridToggle = $('gridToggle'), gridOverlay = $('gridOverlay'), snapIndicator = $('snapIndicator'), snapToggle = $('snapToggle');
const textMoveToggle = $('textMoveToggle'), textReset = $('textReset');
const loadingOverlay = $('loadingOverlay'), loadingProgressBar = $('loadingProgressBar');
const loadingCity = $('loadingCity'), loadingPct = $('loadingPct'), loadingStats = $('loadingStats'), loadingTime = $('loadingTime');
const step1 = $('step1'), step2 = $('step2'), step3 = $('step3'), step4 = $('step4');
const step1Detail = $('step1Detail'), step2Detail = $('step2Detail'), step3Detail = $('step3Detail'), step4Detail = $('step4Detail');
const cityFontSizeEl = $('cityFontSize'), subtitleFontSizeEl = $('subtitleFontSize');
const citySearchEl = $('citySearch'), sortOrder = $('sortOrder');
const citySearchOpen = $('citySearchOpen');
const cityQuickSearchEl = $('cityQuickSearch'), cityQuickBtn = $('cityQuickBtn');
const searchModal = $('searchModal'), searchClose = $('searchClose');
const cityListEl = $('cityList'), cityCountEl = $('cityCount');
const sizeSelect = $('sizeSelect'), orientSelect = $('orientSelect');
const radiusPreset = $('radiusPreset');
const bleedToggle = $('bleedToggle');
const cityWeightEl = $('cityWeight'), subtitleWeightEl = $('subtitleWeight');
const citySpacingEl = $('citySpacing'), citySpacingVal = $('citySpacingVal');
const separatorStyleEl = $('separatorStyle');

function setUiTheme(mode, persist = true) {
  document.body.dataset.ui = mode;
  if (mode === 'classic') { uiClassic.classList.add('active'); uiDark.classList.remove('active'); }
  else { uiDark.classList.add('active'); uiClassic.classList.remove('active'); }
  if (persist) localStorage.setItem('ui', mode);
}

function toBase64(str) {
  try {
    return btoa(unescape(encodeURIComponent(str)));
  } catch (e) {
    return '';
  }
}

function fromBase64(str) {
  try {
    return decodeURIComponent(escape(atob(str)));
  } catch (e) {
    return null;
  }
}

function collectState() {
  const customCity = customCityEl?.value?.trim() || '';
  const customCountry = customCountryEl?.value?.trim() || '';
  const isTemp = currentCity && String(currentCity).startsWith('temp-');
  const tempCity = isTemp && CITIES?.[currentCity]
    ? {
        name: CITIES[currentCity].name,
        country: CITIES[currentCity].country || '',
        lat: CITIES[currentCity].lat,
        lon: CITIES[currentCity].lon,
        osm_id: CITIES[currentCity].osm_id || null
      }
    : null;
  
  return {
    v: STATE_VERSION,
    cityKey: currentCity || '',
    tempCity,
    theme: themeEl?.value || '',
    size: sizeSelect?.value || '',
    orient: orientSelect?.value || '',
    font: fontStyleEl?.value || '',
    cityFontSize: parseInt(cityFontSizeEl?.value || 48, 10),
    subtitleFontSize: parseInt(subtitleFontSizeEl?.value || 18, 10),
    cityWeight: parseInt(cityWeightEl?.value || 300, 10),
    subtitleWeight: parseInt(subtitleWeightEl?.value || 400, 10),
    citySpacing: parseInt(citySpacingEl?.value || 10, 10),
    separator: separatorStyleEl?.value || 'line',
    radiusPreset: radiusPreset?.value || 'standard',
    showCoords: showCoordsEl?.checked ? 1 : 0,
    water: waterEl?.checked ? 1 : 0,
    bleed: bleedToggle?.checked ? 1 : 0,
    ui: document.body.dataset.ui || 'dark',
    customCity: customCity,
    customCountry: customCountry,
    zoom: Number.isFinite(zoom) ? Number(zoom.toFixed(3)) : 1,
    panX: Number.isFinite(panX) ? Number(panX.toFixed(1)) : 0,
    panY: Number.isFinite(panY) ? Number(panY.toFixed(1)) : 0,
    textOffsetX: Number.isFinite(textOffsetX) ? Number(textOffsetX.toFixed(4)) : 0,
    textOffsetY: Number.isFinite(textOffsetY) ? Number(textOffsetY.toFixed(4)) : 0
  };
}

function persistState() {
  if (applyingState) return;
  const state = collectState();
  try {
    localStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(state));
  } catch (e) { /* ignore */ }
  
  const shouldShare = !!(state.cityKey || state.tempCity);
  const url = new URL(window.location.href);
  if (shouldShare) {
    const encoded = toBase64(JSON.stringify(state));
    if (encoded) url.searchParams.set(URL_STATE_PARAM, encoded);
  } else {
    url.searchParams.delete(URL_STATE_PARAM);
  }
  history.replaceState(null, '', url.toString());
}

function scheduleStateSave() {
  if (applyingState) return;
  clearTimeout(stateSaveTimer);
  stateSaveTimer = setTimeout(persistState, 250);
}

function readStateFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const encoded = params.get(URL_STATE_PARAM);
  if (!encoded) return null;
  const raw = fromBase64(encoded);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch (e) {
    return null;
  }
}

function readStateFromStorage() {
  const raw = localStorage.getItem(STATE_STORAGE_KEY);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch (e) {
    return null;
  }
}

function applyViewState(view) {
  if (!view) return;
  zoom = Number.isFinite(view.zoom) ? view.zoom : zoom;
  panX = Number.isFinite(view.panX) ? view.panX : panX;
  panY = Number.isFinite(view.panY) ? view.panY : panY;
  textOffsetX = Number.isFinite(view.textOffsetX) ? view.textOffsetX : textOffsetX;
  textOffsetY = Number.isFinite(view.textOffsetY) ? view.textOffsetY : textOffsetY;
  zoomLevel.textContent = Math.round(zoom * 100) + '%';
}

function selectTempCityFromState(info) {
  if (!info || !Number.isFinite(info.lat) || !Number.isFinite(info.lon)) return null;
  if (tempCityKey && CITIES[tempCityKey]) delete CITIES[tempCityKey];
  tempCityKey = `temp-${Date.now()}`;
  CITIES[tempCityKey] = {
    name: info.name || 'Custom City',
    country: info.country || '',
    lat: info.lat,
    lon: info.lon,
    osm_id: info.osm_id || null
  };
  return tempCityKey;
}

function applyState(state) {
  if (!state) return false;
  applyingState = true;
  
  try {
    if (state.ui) setUiTheme(state.ui, false);
    if (state.theme && themeEl) themeEl.value = state.theme;
    if (state.size && sizeSelect) sizeSelect.value = state.size;
    if (state.orient && orientSelect) orientSelect.value = state.orient;
    if (state.font && fontStyleEl) fontStyleEl.value = state.font;
    if (state.radiusPreset && radiusPreset) radiusPreset.value = state.radiusPreset;
    if (bleedToggle) bleedToggle.checked = !!state.bleed;
    if (cityWeightEl && Number.isFinite(state.cityWeight)) cityWeightEl.value = state.cityWeight;
    if (subtitleWeightEl && Number.isFinite(state.subtitleWeight)) subtitleWeightEl.value = state.subtitleWeight;
    if (citySpacingEl && Number.isFinite(state.citySpacing)) citySpacingEl.value = state.citySpacing;
    if (separatorStyleEl && state.separator) separatorStyleEl.value = state.separator;
    updateSpacingLabel();
    if (cityFontSizeEl && Number.isFinite(state.cityFontSize)) cityFontSizeEl.value = state.cityFontSize;
    if (subtitleFontSizeEl && Number.isFinite(state.subtitleFontSize)) subtitleFontSizeEl.value = state.subtitleFontSize;
    if (showCoordsEl) showCoordsEl.checked = !!state.showCoords;
    if (waterEl) waterEl.checked = !!state.water;
    
    if (customCityEl) {
      customCityEl.value = state.customCity || '';
      if (customCityEl.value) customCityEl.dataset.userEdited = '1';
      else delete customCityEl.dataset.userEdited;
    }
    if (customCountryEl) {
      customCountryEl.value = state.customCountry || '';
      if (customCountryEl.value) customCountryEl.dataset.userEdited = '1';
      else delete customCountryEl.dataset.userEdited;
    }
    
    pendingViewState = {
      zoom: state.zoom,
      panX: state.panX,
      panY: state.panY,
      textOffsetX: state.textOffsetX,
      textOffsetY: state.textOffsetY
    };
    
    let key = null;
    if (state.cityKey && CITIES?.[state.cityKey]) key = state.cityKey;
    else if (state.tempCity) key = selectTempCityFromState(state.tempCity);
    
    if (key) {
      selectCity(key);
      return true;
    }
  } finally {
    applyingState = false;
  }
  
  return false;
}

// Region mapping
const REGIONS = {
  'North America': ['USA', 'United States', 'Canada', 'Mexico'],
  'South America': ['Brazil', 'Argentina', 'Colombia', 'Chile', 'Peru', 'Venezuela', 'Ecuador', 'Uruguay'],
  'Europe': ['UK', 'United Kingdom', 'France', 'Germany', 'Italy', 'Spain', 'Netherlands', 'Belgium', 'Switzerland', 'Austria', 'Portugal', 'Sweden', 'Norway', 'Denmark', 'Finland', 'Poland', 'Czech Republic', 'Greece', 'Ireland', 'Hungary', 'Romania'],
  'Asia': ['Japan', 'China', 'India', 'South Korea', 'Thailand', 'Vietnam', 'Singapore', 'Malaysia', 'Indonesia', 'Philippines', 'Taiwan', 'Hong Kong', 'UAE', 'Saudi Arabia', 'Israel', 'Turkey', 'Qatar', 'Pakistan', 'Bangladesh'],
  'Africa': ['South Africa', 'Egypt', 'Nigeria', 'Kenya', 'Morocco', 'Ethiopia', 'Ghana', 'Tanzania'],
  'Oceania': ['Australia', 'New Zealand']
};

const REGION_ORDER = ['North America', 'Europe', 'Asia', 'South America', 'Africa', 'Oceania', 'Other'];
let collapsedRegions = new Set();

function getRegion(country) {
  for (const [region, countries] of Object.entries(REGIONS)) {
    if (countries.some(c => country.includes(c) || c.includes(country))) return region;
  }
  return 'Other';
}

// === CITY LIST ===
function renderCityList() {
  if (!CITIES) return;
  const searchTerm = citySearchEl.value.toLowerCase();
  const sort = sortOrder.value;
  
  let cities = Object.entries(CITIES).map(([key, c]) => ({ ...c, key }));
  if (searchTerm) cities = cities.filter(c => c.name.toLowerCase().includes(searchTerm) || c.country.toLowerCase().includes(searchTerm));
  
  // Group by region or sort flat
  if (sort === 'region') {
    // Group cities by region
    const grouped = {};
    cities.forEach(c => {
      const region = getRegion(c.country);
      if (!grouped[region]) grouped[region] = [];
      grouped[region].push(c);
    });
    
    // Sort each group alphabetically
    Object.values(grouped).forEach(arr => arr.sort((a, b) => a.name.localeCompare(b.name)));
    
    // Build HTML with collapsible groups
    let html = '';
    let totalCount = 0;
    REGION_ORDER.forEach(region => {
      const regionCities = grouped[region];
      if (!regionCities || !regionCities.length) return;
      totalCount += regionCities.length;
      const isCollapsed = collapsedRegions.has(region);
      html += `
        <div class="region-group${isCollapsed ? ' collapsed' : ''}" data-region="${region}">
          <div class="region-header" role="button" tabindex="0" aria-expanded="${!isCollapsed}">
            <span class="region-name">${region}</span>
            <span class="region-count">${regionCities.length} <span class="chevron">▼</span></span>
          </div>
          <div class="region-cities">
            ${regionCities.map(c => `
              <div class="city-item" data-key="${c.key}" role="button" tabindex="0">
                <div class="name">${escapeHtml(c.name)}</div>
                <div class="country">${escapeHtml(c.country)}</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    });
    
    cityCountEl.textContent = `${totalCount} cities`;
    cityListEl.innerHTML = html;
    
    // Add region toggle handlers
    cityListEl.querySelectorAll('.region-header').forEach(header => {
      const toggle = (e) => {
        e.stopPropagation();
        const group = header.closest('.region-group');
        const region = group.dataset.region;
        group.classList.toggle('collapsed');
        if (group.classList.contains('collapsed')) collapsedRegions.add(region);
        else collapsedRegions.delete(region);
        header.setAttribute('aria-expanded', String(!group.classList.contains('collapsed')));
      };
      header.onclick = toggle;
      header.onkeydown = (e) => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          toggle(e);
        }
      };
    });
  } else {
    // Flat list sorted
    if (sort === 'name') cities.sort((a, b) => a.name.localeCompare(b.name));
    else if (sort === 'name-desc') cities.sort((a, b) => b.name.localeCompare(a.name));
    
    cityCountEl.textContent = `${cities.length} cities`;
    cityListEl.innerHTML = cities.map(c => `
      <div class="city-item" data-key="${c.key}" role="button" tabindex="0">
        <div class="name">${escapeHtml(c.name)}</div>
        <div class="country">${escapeHtml(c.country)}</div>
      </div>
    `).join('');
  }
  
  // Add city click handlers
  cityListEl.querySelectorAll('.city-item').forEach(item => {
    item.onclick = (e) => {
      e.stopPropagation();
      selectCity(item.dataset.key);
    };
    item.onkeydown = (e) => {
      if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        selectCity(item.dataset.key);
      }
    };
  });
  
  // Highlight current city
  if (currentCity) {
    const active = cityListEl.querySelector(`[data-key="${currentCity}"]`);
    if (active) {
      active.classList.add('active');
      // Expand parent region if collapsed
      const parentGroup = active.closest('.region-group');
      if (parentGroup && parentGroup.classList.contains('collapsed')) {
        parentGroup.classList.remove('collapsed');
        collapsedRegions.delete(parentGroup.dataset.region);
        const header = parentGroup.querySelector('.region-header');
        if (header) header.setAttribute('aria-expanded', 'true');
      }
    }
  }
}

function selectCity(key) {
  const city = CITIES[key];
  if (!city) return;
  
  currentCity = key;
  place = { lat: city.lat, lon: city.lon, osm_type: 'relation', osm_id: city.osm_id, name: city.name, address: { city: city.name, country: city.country } };
  selectedEl.textContent = city.country ? `${city.name}, ${city.country}` : city.name;
  selectedEl.dataset.city = city.name;
  selectedEl.dataset.country = city.country;
  
  cityListEl.querySelectorAll('.city-item').forEach(el => el.classList.remove('active'));
  const active = cityListEl.querySelector(`[data-key="${key}"]`);
  if (active) active.classList.add('active');
  
  scheduleStateSave();
  genBtn.click();
}

citySearchEl.oninput = renderCityList;
sortOrder.onchange = renderCityList;

async function runCityQuickSearch(queryOverride) {
  const query = (queryOverride ?? cityQuickSearchEl?.value)?.trim();
  if (!query) { status('Enter a city to search'); return; }
  cityQuickBtn.disabled = true;
  status(`Searching for "${query}"...`, false, true);
  try {
    const geo = await geocodeCity(query);
    const feature = geo?.features?.[0];
    if (!feature) { status('City not found. Try "City, Country".', true); return; }
    const key = selectTempCityFromFeature(feature);
    if (!key) { status('City not found. Try a more specific search.', true); return; }
    citySearchEl.value = '';
    renderCityList();
    if (cityQuickSearchEl) cityQuickSearchEl.value = '';
    selectCity(key);
    if (searchModal) closeModal(searchModal);
  } catch (e) {
    status('Search failed: ' + e.message, true);
  } finally {
    cityQuickBtn.disabled = false;
  }
}

if (cityQuickBtn && cityQuickSearchEl) {
  cityQuickBtn.onclick = () => runCityQuickSearch();
  cityQuickSearchEl.onkeydown = e => {
    if (e.key === 'Enter') { e.preventDefault(); runCityQuickSearch(); }
  };
}
if (citySearchOpen && searchModal) {
  citySearchOpen.onclick = () => openModal(searchModal);
}

// === GRID TOGGLE ===
let showGrid = false;
let snapEnabled = true;

gridToggle.onclick = () => {
  showGrid = !showGrid;
  gridOverlay.classList.toggle('visible', showGrid);
  gridToggle.classList.toggle('active', showGrid);
};

snapToggle.onclick = () => {
  snapEnabled = !snapEnabled;
  snapToggle.classList.toggle('active', snapEnabled);
};

if (textMoveToggle) {
  textMoveToggle.onclick = () => {
    textMoveEnabled = !textMoveEnabled;
    textMoveToggle.classList.toggle('active', textMoveEnabled);
    if (!textMoveEnabled) isTextDragging = false;
    canvas.style.cursor = textMoveEnabled ? 'move' : 'grab';
  };
}
if (textReset) {
  textReset.onclick = () => {
    textOffsetX = 0;
    textOffsetY = 0;
    scheduleRender();
    scheduleStateSave();
  };
}

// === UI THEME ===
uiClassic.onclick = () => { setUiTheme('classic'); scheduleStateSave(); };
uiDark.onclick = () => { setUiTheme('dark'); scheduleStateSave(); };
if (localStorage.getItem('ui') === 'classic') setUiTheme('classic', false);

themeEl.onchange = () => { invalidatePreviewLayer(); if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };

if (sizeSelect) {
  sizeSelect.onchange = () => {
    if (data) render(canvas, themeEl.value, true);
    scheduleStateSave();
  };
}
if (orientSelect) {
  orientSelect.onchange = () => {
    if (data) render(canvas, themeEl.value, true);
    scheduleStateSave();
  };
}
if (radiusPreset) {
  radiusPreset.onchange = () => {
    scheduleStateSave();
    if (place) genBtn.click();
  };
}

// === UTILITIES ===
function status(msg, err, loading) {
  statusEl.textContent = '';
  if (loading) {
    const spinner = document.createElement('span');
    spinner.className = 'spinner';
    statusEl.appendChild(spinner);
  }
  statusEl.appendChild(document.createTextNode(String(msg ?? '')));
  statusEl.className = 'status-bar' + (err ? ' error' : '') + (loading ? ' loading' : '');
}

function setProgress(pct) {
  if (pct === null) { progressEl.classList.remove('active'); return; }
  progressEl.classList.add('active');
  progressBar.style.width = pct + '%';
}

function updatePreviewHint() {
  if (!previewHint) return;
  const isLoading = !loadingOverlay.classList.contains('hidden');
  const show = !data && !isLoading;
  previewHint.classList.toggle('hidden', !show);
}

function updateSpacingLabel() {
  if (!citySpacingVal || !citySpacingEl) return;
  citySpacingVal.textContent = `${citySpacingEl.value}px`;
}

function setBoundaryDebug(info) {
  if (!boundaryDebugEl) return;
  if (!info) { boundaryDebugEl.textContent = 'Boundary: none'; return; }
  const lvl = info.adminLevel ? `admin ${info.adminLevel}` : 'admin ?';
  const score = Number.isFinite(info.score) ? `score ${info.score}` : 'score ?';
  const name = info.name ? `name "${info.name}"` : '';
  boundaryDebugEl.textContent = `Boundary: rel ${info.id} (${lvl}, ${score}) ${name}`.trim();
}

function isMobileDevice() {
  const ua = navigator.userAgent || '';
  const isUA = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
  const coarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
  const small = Math.min(window.innerWidth, window.innerHeight) < 900;
  return isUA || (coarse && small);
}

function updateMobileBlocker() {
  const blocker = document.getElementById('mobileBlocker');
  if (!blocker) return;
  const blocked = isMobileDevice();
  blocker.classList.toggle('active', blocked);
  blocker.setAttribute('aria-hidden', blocked ? 'false' : 'true');
  document.body.classList.toggle('mobile-blocked', blocked);
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

function abortActiveRequests() {
  activeControllers.forEach(c => c.abort());
  activeControllers.clear();
}

function cacheKey(areaId, lat, lon, radius) {
  const id = areaId ? `a${areaId}` : `r${lat.toFixed(4)}:${lon.toFixed(4)}:${radius}`;
  return id;
}

function cacheGet(map, key) {
  const entry = map.get(key);
  if (!entry) return null;
  if (Date.now() - entry.ts > CACHE_TTL_MS) { map.delete(key); return null; }
  return entry.value;
}

function cacheSet(map, key, value) {
  map.set(key, { value, ts: Date.now() });
  if (map.size <= CACHE_MAX_ENTRIES) return;
  let oldestKey = null;
  let oldestTs = Infinity;
  for (const [k, v] of map.entries()) {
    if (v.ts < oldestTs) { oldestTs = v.ts; oldestKey = k; }
  }
  if (oldestKey) map.delete(oldestKey);
}

function escapeOverpass(value) {
  return String(value || '').replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}

function escapeOverpassRegex(value) {
  return String(value || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function getSize() {
  const sizeVal = sizeSelect?.value || '5x7';
  const orientVal = orientSelect?.value || 'portrait';
  const [w, h] = SIZES[sizeVal][orientVal];
  return { w, h, orient: orientVal, label: sizeVal };
}

function getBleedPx() {
  return bleedToggle?.checked ? BLEED_PX : 0;
}

function getExportMapTransform(size) {
  if (!previewRender) return null;
  if (zoom === 1 && panX === 0 && panY === 0) return null;
  const scaleX = previewRender.w ? size.w / previewRender.w : 1;
  const scaleY = previewRender.h ? size.h / previewRender.h : 1;
  return {
    zoom,
    panX: panX * scaleX,
    panY: panY * scaleY
  };
}

function applyMapTransform(ctx, size, transform) {
  if (!transform) return;
  const cx = size.w / 2;
  const cy = size.h / 2;
  ctx.translate(cx + transform.panX, cy + transform.panY);
  ctx.scale(transform.zoom, transform.zoom);
  ctx.translate(-cx, -cy);
}
</script>
<script>
// === FETCH DATA ===
async function fetchWithRetry(url, options, retries = 3, timeoutMs = FETCH_TIMEOUT_MS) {
  for (let i = 0; i < retries; i++) {
    let controller = new AbortController();
    let timeoutId = null;
    let didTimeout = false;
    let onAbort = null;
    
    try {
      if (options?.signal) {
        onAbort = () => controller.abort();
        if (options.signal.aborted) onAbort();
        else options.signal.addEventListener('abort', onAbort, { once: true });
      }
      
      timeoutId = setTimeout(() => { didTimeout = true; controller.abort(); }, timeoutMs);
      activeControllers.add(controller);
      
      const res = await fetch(url, { ...(options || {}), signal: controller.signal });
      if (res.ok) return res;
      if (res.status === 429 || res.status >= 500) {
        const retryAfter = parseInt(res.headers.get('Retry-After') || '', 10);
        const baseDelay = Math.min(10000, 1000 * Math.pow(2, i));
        const jitter = Math.floor(Math.random() * 400);
        const waitMs = Number.isFinite(retryAfter) ? retryAfter * 1000 : baseDelay + jitter;
        await delay(waitMs);
        continue;
      }
      throw new Error(`HTTP ${res.status}`);
    } catch (e) {
      if (e?.name === 'AbortError') {
        const msg = didTimeout ? 'Request timed out' : 'Request canceled';
        throw new Error(msg);
      } else if (i === retries - 1) {
        throw e;
      }
      const baseDelay = Math.min(10000, 1000 * Math.pow(2, i));
      const jitter = Math.floor(Math.random() * 400);
      await delay(baseDelay + jitter);
    } finally {
      if (timeoutId) clearTimeout(timeoutId);
      activeControllers.delete(controller);
      if (options?.signal && onAbort) options.signal.removeEventListener('abort', onAbort);
    }
  }
}

async function fetchJsonWithRetry(url, options, retries = 3, timeoutMs = FETCH_TIMEOUT_MS) {
  const res = await fetchWithRetry(url, options, retries, timeoutMs);
  return await res.json();
}

async function fetchOverpass(query, retries = 3, timeoutMs = OVERPASS_TIMEOUT_MS, label) {
  let lastErr = null;
  for (let i = 0; i < OVERPASS_ENDPOINTS.length; i++) {
    const endpoint = OVERPASS_ENDPOINTS[i];
    try {
      if (i > 0 && label) status(`${label} (trying backup ${i + 1}/${OVERPASS_ENDPOINTS.length})`, false, true);
      const res = await fetchWithRetry(endpoint, { method: 'POST', body: query }, retries, timeoutMs);
      return res;
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error('Overpass request failed');
}

async function fetchStreets(areaId, lat, lon, radius) {
  const types = ROAD_TYPES.join('|');
  const useArea = !!areaId;
  const streetQ = useArea
    ? `[out:json][timeout:180];area(${areaId})->.a;way(area.a)["highway"~"^(${types})$"];out geom;`
    : `[out:json][timeout:180];way["highway"~"^(${types})$"](around:${radius},${lat},${lon});out geom;`;
  
  const streetRes = await fetchOverpass(streetQ, 3, OVERPASS_TIMEOUT_MS, 'Overpass busy, fetching streets');
  const streetJson = await streetRes.json();
  if (useArea && (!streetJson.elements || streetJson.elements.length === 0)) {
    const fallbackQ = `[out:json][timeout:180];way["highway"~"^(${types})$"](around:${radius},${lat},${lon});out geom;`;
    const fallbackRes = await fetchOverpass(fallbackQ, 2, OVERPASS_TIMEOUT_MS, 'Overpass busy, fetching streets');
    return await fallbackRes.json();
  }
  return streetJson;
}

async function fetchWater(areaId, lat, lon, radius) {
  if (!waterEl.checked) return { elements: [] };
  
  const useArea = !!areaId;
  const waterQ = useArea
    ? `[out:json][timeout:90];area(${areaId})->.a;relation(area.a)["natural"="water"]->.rels;(way(area.a)["natural"="water"];way(area.a)["waterway"~"river|canal|stream|riverbank"];way(area.a)["natural"="coastline"];way(r.rels););out geom;`
    : `[out:json][timeout:90];relation(around:${radius},${lat},${lon})["natural"="water"]->.rels;(way["natural"="water"](around:${radius},${lat},${lon});way["waterway"~"river|canal|stream|riverbank"](around:${radius},${lat},${lon});way["natural"="coastline"](around:${radius},${lat},${lon});way(r.rels););out geom;`;
  
  try {
    const waterRes = await fetchOverpass(waterQ, 3, OVERPASS_TIMEOUT_MS, 'Overpass busy, fetching water');
    const waterJson = await waterRes.json();
    if (useArea && (!waterJson.elements || waterJson.elements.length === 0)) {
      const fallbackQ = `[out:json][timeout:90];(way["natural"="water"](around:${radius},${lat},${lon});way["waterway"~"river|canal|stream|riverbank"](around:${radius},${lat},${lon});way["natural"="coastline"](around:${radius},${lat},${lon}););out geom;`;
      const fallbackRes = await fetchOverpass(fallbackQ, 2, OVERPASS_TIMEOUT_MS, 'Overpass busy, fetching water');
      return await fallbackRes.json();
    }
    return waterJson;
  } catch (e) {
    console.warn('Water fetch failed', e);
    return { elements: [] };
  }
}

async function fetchStreetsCached(areaId, lat, lon, radius) {
  const key = cacheKey(areaId, lat, lon, radius);
  const cached = cacheGet(STREET_CACHE, key);
  if (cached) return { result: cached, fromCache: true };
  const result = await fetchStreets(areaId, lat, lon, radius);
  cacheSet(STREET_CACHE, key, result);
  return { result, fromCache: false };
}

async function fetchWaterCached(areaId, lat, lon, radius) {
  if (!waterEl.checked) return { result: { elements: [] }, fromCache: false };
  const key = cacheKey(areaId, lat, lon, radius);
  const cached = cacheGet(WATER_CACHE, key);
  if (cached) return { result: cached, fromCache: true };
  const result = await fetchWater(areaId, lat, lon, radius);
  cacheSet(WATER_CACHE, key, result);
  return { result, fromCache: false };
}

async function fetchGeocodeCached(cityName, countryName) {
  const key = `${cityName.toLowerCase()}|${countryName.toLowerCase()}`;
  const cached = cacheGet(GEOCODE_CACHE, key);
  if (cached) return cached;
  const data = await fetchJsonWithRetry(`https://photon.komoot.io/api/?q=${encodeURIComponent(cityName + ', ' + countryName)}&limit=1`, { method: 'GET' }, 2, PHOTON_TIMEOUT_MS);
  cacheSet(GEOCODE_CACHE, key, data);
  return data;
}

function uniqueNames(names) {
  const out = [];
  const seen = new Set();
  names.forEach(n => {
    const v = String(n || '').trim();
    if (!v) return;
    const key = v.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    out.push(v);
  });
  return out;
}

function extractNameHintsFromPhoton(feature) {
  if (!feature || !feature.properties) return [];
  const props = feature.properties;
  return uniqueNames([
    props.name,
    props.city,
    props.locality,
    props.district,
    props.county
  ]);
}

async function geocodeCity(query) {
  const cleaned = String(query || '').trim();
  if (!cleaned) return null;
  const parts = cleaned.split(',').map(p => p.trim()).filter(Boolean);
  const city = parts[0] || cleaned;
  const country = parts.slice(1).join(', ');
  return await fetchGeocodeCached(city, country);
}

function featureToCity(feature) {
  if (!feature) return null;
  const props = feature.properties || {};
  const [lon, lat] = feature.geometry?.coordinates || [];
  if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
  const name = props.name || props.city || props.locality || props.district || props.county || 'Unknown';
  const country = props.country || (props.countrycode ? String(props.countrycode).toUpperCase() : '') || props.state || '';
  const osmId = props.osm_type === 'R' ? props.osm_id : null;
  return { name, country, lat, lon, osm_id: osmId };
}

function selectTempCityFromFeature(feature) {
  const city = featureToCity(feature);
  if (!city) return null;
  if (tempCityKey && CITIES[tempCityKey]) delete CITIES[tempCityKey];
  tempCityKey = `temp-${Date.now()}`;
  CITIES[tempCityKey] = city;
  return tempCityKey;
}

async function fetchBoundaryRelation(lat, lon, name, country, countryCode) {
  const key = `${name.toLowerCase()}|${(country || '').toLowerCase()}|${(countryCode || '').toLowerCase()}|${lat.toFixed(3)}|${lon.toFixed(3)}`;
  const cached = cacheGet(BOUNDARY_CACHE, key);
  if (cached !== null) {
    if (cached === 0) return null;
    return cached;
  }
  if (!name) { cacheSet(BOUNDARY_CACHE, key, 0); return null; }
  
  const safeRegex = escapeOverpassRegex(name);
  const radius = DEFAULT_RADIUS * 3;
  const adminLevels = "2|4|6|7|8|9|10";
  const q = `[out:json][timeout:60];(` +
    `relation["boundary"="administrative"]["admin_level"~"${adminLevels}"]["name"~"^${safeRegex}$",i](around:${radius},${lat},${lon});` +
    `relation["boundary"="administrative"]["admin_level"~"${adminLevels}"]["name:en"~"^${safeRegex}$",i](around:${radius},${lat},${lon});` +
    `);out tags;`;
  
  try {
    const res = await fetchOverpass(q, 2, OVERPASS_TIMEOUT_MS, 'Overpass busy, resolving boundary');
    const json = await res.json();
    const rels = (json.elements || []).filter(e => e.type === 'relation');
    if (!rels.length) { cacheSet(BOUNDARY_CACHE, key, 0); return null; }
    
    const score = (rel) => {
      const lvl = parseInt(rel.tags?.admin_level || '99', 10);
      const nameTag = rel.tags?.name || rel.tags?.['name:en'] || '';
      const exact = nameTag.toLowerCase() === name.toLowerCase() ? 0 : 5;
      const countryName = String(country || '').toLowerCase();
      const nameLower = nameTag.toLowerCase();
      const isCountryName = countryName && nameLower === countryName;
      const lvlScore = isCountryName
        ? (lvl === 2 ? 0 : lvl === 4 ? 1 : 2)
        : (lvl === 8 ? 0 : lvl === 9 ? 1 : lvl === 7 ? 2 : lvl === 6 ? 3 : lvl === 4 ? 4 : 5);
      const code = String(countryCode || '').toUpperCase();
      const isoTags = [
        rel.tags?.['ISO3166-1:alpha2'],
        rel.tags?.['ISO3166-1'],
        rel.tags?.['ISO3166-1:alpha3'],
        rel.tags?.['addr:country'],
        rel.tags?.['is_in:country_code'],
        rel.tags?.['country_code']
      ].filter(Boolean).map(v => String(v).toUpperCase());
      const inCountry = String(rel.tags?.['is_in:country'] || rel.tags?.['addr:country'] || '').toLowerCase();
      let countryScore = 3;
      if (code && isoTags.some(v => v === code)) countryScore = 0;
      else if (countryName && inCountry.includes(countryName)) countryScore = 1;
      return exact * 10 + lvlScore + countryScore;
    };
    rels.sort((a, b) => score(a) - score(b));
    const best = rels[0];
    const info = {
      id: best.id,
      adminLevel: best.tags?.admin_level || '',
      name: best.tags?.name || best.tags?.['name:en'] || '',
      score: score(best)
    };
    cacheSet(BOUNDARY_CACHE, key, info);
    return info;
  } catch (e) {
    console.warn('Boundary resolve failed', e);
    cacheSet(BOUNDARY_CACHE, key, 0);
    return null;
  }
}

async function fetchBoundaryRelationFromNames(lat, lon, names, country, countryCode) {
  const list = uniqueNames(names);
  for (const name of list) {
    const info = await fetchBoundaryRelation(lat, lon, name, country, countryCode);
    if (info && info.id) return info;
  }
  return null;
}

async function fetchBoundaryBounds(relationId) {
  if (!relationId) return null;
  const key = String(relationId);
  const cached = cacheGet(BOUNDARY_BOUNDS_CACHE, key);
  if (cached !== null) return cached || null;
  
  try {
    const q = `[out:json][timeout:60];relation(${relationId});out bb;`;
    const res = await fetchOverpass(q, 2, OVERPASS_TIMEOUT_MS, 'Overpass busy, fetching boundary');
    const json = await res.json();
    const rel = (json.elements || []).find(e => e.type === 'relation');
    const bb = rel?.bounds;
    if (!bb) { cacheSet(BOUNDARY_BOUNDS_CACHE, key, 0); return null; }
    const bounds = { minLat: bb.minlat, maxLat: bb.maxlat, minLon: bb.minlon, maxLon: bb.maxlon };
    cacheSet(BOUNDARY_BOUNDS_CACHE, key, bounds);
    return bounds;
  } catch (e) {
    console.warn('Boundary bounds failed', e);
    cacheSet(BOUNDARY_BOUNDS_CACHE, key, 0);
    return null;
  }
}

// Batch processing helper - uses fetchStreets/fetchWater with progress callbacks
async function fetchData(areaId, lat, lon, radius, onProgress) {
  status('Fetching street data...', false, true);
  onProgress?.(20);
  const streets = await fetchStreets(areaId, lat, lon, radius);
  onProgress?.(60);
  
  status('Fetching water bodies...', false, true);
  onProgress?.(70);
  const water = await fetchWater(areaId, lat, lon, radius);
  onProgress?.(85);
  
  onProgress?.(90);
  return { streets, water };
}

function calcBounds(streets, water) {
  let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
  let hasPoints = false;
  const process = els => els.forEach(el => {
    (el.geometry || []).forEach(p => {
      hasPoints = true;
      minLat = Math.min(minLat, p.lat); maxLat = Math.max(maxLat, p.lat);
      minLon = Math.min(minLon, p.lon); maxLon = Math.max(maxLon, p.lon);
    });
  });
  process(streets.elements || []);
  process(water.elements || []);
  if (!hasPoints || !Number.isFinite(minLat) || !Number.isFinite(minLon)) return null;
  const pad = 0.05;
  return { minLat: minLat - (maxLat-minLat)*pad, maxLat: maxLat + (maxLat-minLat)*pad, minLon: minLon - (maxLon-minLon)*pad, maxLon: maxLon + (maxLon-minLon)*pad };
}

function normalizeBounds(bounds, minSpan = 0.0005) {
  const latSpan = Math.max(bounds.maxLat - bounds.minLat, minSpan);
  const lonSpan = Math.max(bounds.maxLon - bounds.minLon, minSpan);
  const latC = (bounds.minLat + bounds.maxLat) / 2;
  const lonC = (bounds.minLon + bounds.maxLon) / 2;
  return { minLat: latC - latSpan / 2, maxLat: latC + latSpan / 2, minLon: lonC - lonSpan / 2, maxLon: lonC + lonSpan / 2 };
}

function fallbackBounds(lat, lon, radiusM) {
  const latDelta = radiusM / 111000;
  const lonDelta = radiusM / (111000 * Math.cos(lat * Math.PI / 180) || 1);
  return { minLat: lat - latDelta, maxLat: lat + latDelta, minLon: lon - lonDelta, maxLon: lon + lonDelta };
}

function mergeBounds(a, b) {
  if (!a) return b;
  if (!b) return a;
  return {
    minLat: Math.min(a.minLat, b.minLat),
    maxLat: Math.max(a.maxLat, b.maxLat),
    minLon: Math.min(a.minLon, b.minLon),
    maxLon: Math.max(a.maxLon, b.maxLon)
  };
}

function mergeBoundsSafe(bounds, boundaryBounds) {
  if (!bounds || !boundaryBounds) return mergeBounds(bounds, boundaryBounds);
  const dataArea = Math.abs((bounds.maxLat - bounds.minLat) * (bounds.maxLon - bounds.minLon));
  const boundaryArea = Math.abs((boundaryBounds.maxLat - boundaryBounds.minLat) * (boundaryBounds.maxLon - boundaryBounds.minLon));
  if (Number.isFinite(dataArea) && dataArea > 0 && Number.isFinite(boundaryArea) && boundaryArea > dataArea * 6) {
    console.warn('Boundary bounds skipped due to scale mismatch', { dataArea, boundaryArea });
    return bounds;
  }
  return mergeBounds(bounds, boundaryBounds);
}

function radiusFromBounds(bounds) {
  const latSpanM = (bounds.maxLat - bounds.minLat) * 111000;
  const lonSpanM = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(((bounds.minLat + bounds.maxLat) / 2) * Math.PI / 180);
  const diag = Math.hypot(latSpanM, lonSpanM);
  return Math.min(MAX_RADIUS, Math.max(DEFAULT_RADIUS, Math.round(diag * 0.55)));
}

function escapeHtml(text) {
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function escapeXml(text) {
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

function expandHex(hex) {
  return hex.length === 4 ? '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3] : hex;
}

function getDisplayNames() {
  const city = customCityEl.value.trim() || data?.city || '';
  const country = customCountryEl.value.trim() || data?.country || '';
  return { city, country };
}

function updateAutoTextInputs() {
  if (!data) return;
  const autoCity = data.city || selectedEl.dataset.city || place?.name || '';
  const autoCountry = data.country || selectedEl.dataset.country || place?.address?.country || '';
  
  if (customCityEl) {
    if (!customCityEl.dataset.userEdited) customCityEl.value = autoCity;
    customCityEl.placeholder = autoCity || 'Auto-detect';
    customCityEl.dataset.autoValue = autoCity;
  }
  if (customCountryEl) {
    if (!customCountryEl.dataset.userEdited) customCountryEl.value = autoCountry;
    customCountryEl.placeholder = autoCountry || 'Auto-detect';
    customCountryEl.dataset.autoValue = autoCountry;
  }
}

function invalidatePreviewLayer() {
  previewLayer = null;
  previewLayerKey = '';
  previewProjCache = null;
  previewProjKey = '';
}

function computeLayout(size, scale) {
  const { w: fullW, h: fullH, orient } = size;
  const w = Math.round(fullW * scale), h = Math.round(fullH * scale);
  const margin = Math.min(w, h) * 0.05;
  const isLandscape = orient === 'landscape';
  const mapW = w - margin * 2;
  const mapH = isLandscape ? h * 0.68 : h * 0.72;
  const mapTop = margin;
  
  const b = data.bounds;
  const dataAspect = (b.maxLon - b.minLon) / (b.maxLat - b.minLat);
  const mapAspect = mapW / mapH;
  const adj = { ...b };
  
  if (dataAspect > mapAspect) {
    const latC = (b.minLat + b.maxLat) / 2, range = (b.maxLon - b.minLon) / mapAspect;
    adj.minLat = latC - range / 2; adj.maxLat = latC + range / 2;
  } else {
    const lonC = (b.minLon + b.maxLon) / 2, range = (b.maxLat - b.minLat) * mapAspect;
    adj.minLon = lonC - range / 2; adj.maxLon = lonC + range / 2;
  }
  
  const proj = (lat, lon) => [
    margin + ((lon - adj.minLon) / (adj.maxLon - adj.minLon)) * mapW,
    mapTop + ((adj.maxLat - lat) / (adj.maxLat - adj.minLat)) * mapH
  ];
  
  return { w, h, margin, mapW, mapH, mapTop, isLandscape, proj };
}

function drawGeometry(ctx, geom, proj, minDistSq, step = 1) {
  if (!geom || geom.length < 2) return;
  let lastX = null;
  let lastY = null;
  const lastIndex = geom.length - 1;
  for (let i = 0; i < geom.length; i += step) {
    const p = geom[i];
    const [x, y] = proj(p.lat, p.lon);
    if (lastX === null) {
      ctx.moveTo(x, y);
      lastX = x; lastY = y;
      continue;
    }
    const dx = x - lastX;
    const dy = y - lastY;
    const isLast = i >= lastIndex;
    if (!isLast && minDistSq > 0 && (dx * dx + dy * dy) < minDistSq) continue;
    ctx.lineTo(x, y);
    lastX = x; lastY = y;
  }
  // Ensure last point is included
  if (step > 1) {
    const p = geom[lastIndex];
    const [x, y] = proj(p.lat, p.lon);
    const dx = x - lastX;
    const dy = y - lastY;
    if ((dx * dx + dy * dy) >= minDistSq) ctx.lineTo(x, y);
  }
}

function buildProjectedGeometry(layout, step, minDistSq) {
  const proj = layout.proj;
  const build = (geom) => {
    if (!geom || geom.length < 2) return [];
    const points = [];
    let lastX = null;
    let lastY = null;
    const lastIndex = geom.length - 1;
    for (let i = 0; i < geom.length; i += step) {
      const p = geom[i];
      const [x, y] = proj(p.lat, p.lon);
      if (lastX === null) {
        points.push(x, y);
        lastX = x; lastY = y;
        continue;
      }
      const dx = x - lastX;
      const dy = y - lastY;
      const isLast = i >= lastIndex;
      if (!isLast && minDistSq > 0 && (dx * dx + dy * dy) < minDistSq) continue;
      points.push(x, y);
      lastX = x; lastY = y;
    }
    if (step > 1) {
      const p = geom[lastIndex];
      const [x, y] = proj(p.lat, p.lon);
      const dx = x - lastX;
      const dy = y - lastY;
      if ((dx * dx + dy * dy) >= minDistSq) points.push(x, y);
    }
    return points;
  };
  
  const roads = {};
  const groups = data.groups || buildRoadGroups(data.streets.elements || []);
  Object.entries(groups).forEach(([k, arr]) => {
    roads[k] = arr.map(r => build(r.geometry));
  });
  
  const waters = (data.water?.elements || []).map(el => ({
    closed: el.geometry && el.geometry.length > 1 && el.geometry[0].lat === el.geometry[el.geometry.length - 1].lat && el.geometry[0].lon === el.geometry[el.geometry.length - 1].lon,
    coastline: el.tags?.natural === 'coastline',
    points: build(el.geometry)
  }));
  
  return { roads, waters };
}

function drawWater(ctx, layout, theme, scale, roadWeight, minDistSq, step) {
  const { proj } = layout;
  ctx.fillStyle = theme.water;
  ctx.strokeStyle = theme.water;
  ctx.lineWidth = 1.5 * scale * roadWeight;
  data.water.elements.forEach(el => {
    if (!el.geometry) return;
    ctx.beginPath();
    drawGeometry(ctx, el.geometry, proj, minDistSq, step);
    const g = el.geometry;
    const isClosed = g[0].lat === g[g.length-1].lat && g[0].lon === g[g.length-1].lon;
    const isCoastline = el.tags?.natural === 'coastline';
    (!isCoastline && isClosed) ? ctx.fill() : ctx.stroke();
  });
}

function drawRoadGroup(ctx, layout, theme, scale, roadWeight, roads, colorIdx, minDistSq, step) {
  if (!roads.length) return;
  ctx.strokeStyle = theme.roads[colorIdx];
  ctx.lineWidth = BASE_WIDTHS[colorIdx] * scale * roadWeight * (scale < 1 ? 1.3 : 1);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  roads.forEach(r => { drawGeometry(ctx, r.geometry, layout.proj, minDistSq, step); });
  ctx.stroke();
}

function drawProjectedWater(ctx, theme, scale, roadWeight, waters) {
  ctx.fillStyle = theme.water;
  ctx.strokeStyle = theme.water;
  ctx.lineWidth = 1.5 * scale * roadWeight;
  waters.forEach(w => {
    if (!w.points || w.points.length < 4) return;
    ctx.beginPath();
    ctx.moveTo(w.points[0], w.points[1]);
    for (let i = 2; i < w.points.length; i += 2) ctx.lineTo(w.points[i], w.points[i + 1]);
    (!w.coastline && w.closed) ? ctx.fill() : ctx.stroke();
  });
}

function drawProjectedRoadGroup(ctx, theme, scale, roadWeight, colorIdx, roads) {
  if (!roads.length) return;
  ctx.strokeStyle = theme.roads[colorIdx];
  ctx.lineWidth = BASE_WIDTHS[colorIdx] * scale * roadWeight * (scale < 1 ? 1.3 : 1);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  roads.forEach(points => {
    if (!points || points.length < 4) return;
    ctx.moveTo(points[0], points[1]);
    for (let i = 2; i < points.length; i += 2) ctx.lineTo(points[i], points[i + 1]);
  });
  ctx.stroke();
}

function buildRoadGroups(elements) {
  const groups = { motorway: [], primary: [], secondary: [], tertiary: [], residential: [] };
  (elements || []).forEach(el => {
    if (el.type !== 'way' || !el.geometry) return;
    const hw = el.tags?.highway?.replace('_link', '') || '';
    if (hw === 'motorway' || hw === 'trunk') groups.motorway.push(el);
    else if (hw === 'primary') groups.primary.push(el);
    else if (hw === 'secondary') groups.secondary.push(el);
    else if (hw === 'tertiary') groups.tertiary.push(el);
    else groups.residential.push(el);
  });
  return groups;
}

function drawMapLayer(ctx, layout, theme, scale, roadWeight) {
  const minDistSq = scale < 1 ? PREVIEW_SIMPLIFY_PX * PREVIEW_SIMPLIFY_PX : 0;
  const totalFeatures = (data.totalFeatures ?? ((data.streets.elements || []).length + (data.water?.elements || []).length));
  const fastPreview = scale < 1 && totalFeatures > PREVIEW_FAST_THRESHOLD;
  const skipWater = fastPreview;
  const step = fastPreview ? 2 : 1;
  const useProjCache = scale < 1;
  
  // Water
  if (useProjCache) {
    const projKey = `${dataVersion}|${layout.w}x${layout.h}|${step}|${minDistSq.toFixed(4)}`;
    if (!previewProjCache || previewProjKey !== projKey) {
      previewProjCache = buildProjectedGeometry(layout, step, minDistSq);
      previewProjKey = projKey;
    }
    
    if (!skipWater && waterEl.checked && previewProjCache.waters?.length) {
      drawProjectedWater(ctx, theme, scale, roadWeight, previewProjCache.waters);
    }
    
    const order = fastPreview ? ['tertiary', 'secondary', 'primary', 'motorway'] : ['residential', 'tertiary', 'secondary', 'primary', 'motorway'];
    order.forEach((grp, i) => {
      const roads = previewProjCache.roads?.[grp] || [];
      drawProjectedRoadGroup(ctx, theme, scale, roadWeight, 4 - i, roads);
    });
    return;
  }
  
  if (!skipWater && waterEl.checked && data.water?.elements) {
    drawWater(ctx, layout, theme, scale, roadWeight, minDistSq, step);
  }
  
  // Roads
  const groups = data.groups || buildRoadGroups(data.streets.elements || []);
  
  const order = fastPreview ? ['tertiary', 'secondary', 'primary', 'motorway'] : ['residential', 'tertiary', 'secondary', 'primary', 'motorway'];
  order.forEach((grp, i) => {
    const roads = groups[grp];
    drawRoadGroup(ctx, layout, theme, scale, roadWeight, roads, 4 - i, minDistSq, step);
  });
}

async function drawMapLayerProgressive(ctx, layout, theme, scale, roadWeight, onProgress) {
  const minDistSq = scale < 1 ? PREVIEW_SIMPLIFY_PX * PREVIEW_SIMPLIFY_PX : 0;
  const totalFeatures = (data.totalFeatures ?? ((data.streets.elements || []).length + (data.water?.elements || []).length));
  const fastPreview = scale < 1 && totalFeatures > PREVIEW_FAST_THRESHOLD;
  const skipWater = fastPreview;
  const step = fastPreview ? 2 : 1;
  
  if (!skipWater && waterEl.checked && data.water?.elements) {
    drawWater(ctx, layout, theme, scale, roadWeight, minDistSq, step);
  }
  
  const groups = data.groups || buildRoadGroups(data.streets.elements || []);
  
  const order = fastPreview ? ['tertiary', 'secondary', 'primary', 'motorway'] : ['residential', 'tertiary', 'secondary', 'primary', 'motorway'];
  let drawn = 0;
  const total = order.reduce((sum, grp) => sum + (groups[grp]?.length || 0), 0);
  
  for (const grp of order) {
    const roads = groups[grp];
    if (!roads.length) continue;
    const colorIdx = grp === 'motorway' ? 0 : grp === 'primary' ? 1 : grp === 'secondary' ? 2 : grp === 'tertiary' ? 3 : 4;
    ctx.strokeStyle = theme.roads[colorIdx];
    ctx.lineWidth = BASE_WIDTHS[colorIdx] * scale * roadWeight * (scale < 1 ? 1.3 : 1);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    for (let i = 0; i < roads.length; i += PREVIEW_CHUNK_SIZE) {
      ctx.beginPath();
      const end = Math.min(i + PREVIEW_CHUNK_SIZE, roads.length);
      for (let j = i; j < end; j++) {
        drawGeometry(ctx, roads[j].geometry, layout.proj, minDistSq, step);
      }
      ctx.stroke();
      drawn += (end - i);
      onProgress?.(Math.min(100, Math.round((drawn / total) * 100)));
      await new Promise(r => requestAnimationFrame(r));
    }
  }
}

function getQualityScale(z) {
  if (z >= 2.5) return 3;
  if (z >= 1.7) return 2;
  if (z >= 1.2) return 1.5;
  return 1;
}

// === RENDER ===
function render(cvs, themeKey, isPreview, scaleOverride, sizeOverride, options) {
  if (!data) return;
  const size = sizeOverride || getSize();
  const theme = THEMES[themeKey];
  let scale = scaleOverride || (isPreview ? 0.35 : 1);
  const qualityScale = isPreview && cvs === canvas ? getQualityScale(zoom) : 1;
  const roadWeight = DEFAULT_ROAD_WEIGHT;
  const font = fontStyleEl?.value || 'system-ui, sans-serif';
  const cityWeight = parseInt(cityWeightEl?.value || 300, 10);
  const subtitleWeight = parseInt(subtitleWeightEl?.value || 400, 10);
  const citySpacing = parseInt(citySpacingEl?.value || 10, 10);
  const separatorStyle = separatorStyleEl?.value || 'line';
  const showCoords = showCoordsEl?.checked !== false;
  const { city, country } = getDisplayNames();
  const ignorePanZoom = options?.ignorePanZoom === true;
  const mapTransform = options?.mapTransform || null;
  
  if (isPreview && !scaleOverride) {
    const { w: fullW, h: fullH } = size;
    const w = Math.round(fullW * scale);
    const h = Math.round(fullH * scale);
    const capScale = Math.min(PREVIEW_MAX_W / w, PREVIEW_MAX_H / h, 1);
    scale = scale * capScale;
  }
  
  const layout = computeLayout(size, scale);
  const { w, h, margin, mapW, mapH, mapTop, isLandscape } = layout;
  cvs.width = w; cvs.height = h;
  const ctx = cvs.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  if (isPreview && cvs === canvas) previewRender = { w, h, scale };
  
  ctx.fillStyle = theme.bg;
  ctx.fillRect(0, 0, w, h);
  
  if (isPreview) {
    const key = `${dataVersion}|${themeKey}|${size.label}|${size.orient}|${w}x${h}|${roadWeight}|${waterEl.checked ? 1 : 0}|${scale.toFixed(4)}|q${qualityScale}`;
    if (!previewLayer || previewLayerKey !== key) {
      progressiveToken += 1;
      const token = progressiveToken;
      previewLayer = document.createElement('canvas');
      previewLayer.width = Math.round(w * qualityScale);
      previewLayer.height = Math.round(h * qualityScale);
      const pctx = previewLayer.getContext('2d');
      pctx.setTransform(1, 0, 0, 1, 0, 0);
      pctx.clearRect(0, 0, previewLayer.width, previewLayer.height);
      pctx.setTransform(qualityScale, 0, 0, qualityScale, 0, 0);
      previewProjCache = null;
      previewProjKey = '';
      const totalFeatures = data.totalFeatures ?? ((data.streets.elements || []).length + (data.water?.elements || []).length);
      const fastPreview = scale < 1 && totalFeatures > PREVIEW_FAST_THRESHOLD;
      if (fastPreview) {
        status(`Large city detected (${totalFeatures.toLocaleString()} features). Using fast preview.`, false, true);
      }
      const useProgressive = totalFeatures > PREVIEW_FAST_THRESHOLD * 2;
      if (useProgressive) {
        status(`Rendering ${totalFeatures.toLocaleString()} features in chunks...`, false, true);
        drawMapLayerProgressive(pctx, layout, theme, scale, roadWeight, pct => updateLoadingProgress(pct, `Rendering ${pct}%`))
          .then(() => {
            if (token !== progressiveToken) return;
            previewLayerKey = key;
            if (data) render(canvas, themeEl.value, true);
          });
        return;
      }
      drawMapLayer(pctx, layout, theme, scale, roadWeight);
      previewLayerKey = key;
    }
    
    ctx.save();
    if (!ignorePanZoom && (zoom !== 1 || panX !== 0 || panY !== 0)) {
      ctx.translate(w/2 + panX, h/2 + panY);
      ctx.scale(zoom, zoom);
      ctx.translate(-w/2, -h/2);
    }
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(previewLayer, 0, 0, w, h);
    ctx.restore();
  } else {
    if (mapTransform) {
      ctx.save();
      applyMapTransform(ctx, { w, h }, mapTransform);
      drawMapLayer(ctx, layout, theme, scale, roadWeight);
      ctx.restore();
    } else {
      drawMapLayer(ctx, layout, theme, scale, roadWeight);
    }
  }
  
  const bgColor = expandHex(theme.bg);
  
  // Fades
  if (!isPreview || zoom === 1) {
    const fadeH = h * 0.08;
    let grad = ctx.createLinearGradient(0, 0, 0, fadeH);
    grad.addColorStop(0, bgColor); grad.addColorStop(1, bgColor + '00');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, w, fadeH);
    
    grad = ctx.createLinearGradient(0, mapTop + mapH - fadeH, 0, mapTop + mapH + fadeH * 0.5);
    grad.addColorStop(0, bgColor + '00'); grad.addColorStop(1, bgColor);
    ctx.fillStyle = grad; ctx.fillRect(0, mapTop + mapH - fadeH, w, fadeH * 1.5);
  }
  
  // Text
  const baseTextY = mapTop + mapH + margin * (isLandscape ? 0.6 : 0.8);
  const textX = w / 2 + textOffsetX * w;
  const textY = baseTextY + textOffsetY * h;
  ctx.textAlign = 'center';
  
  // Use custom font sizes from inputs
  const baseCitySize = parseInt(cityFontSizeEl?.value || 48);
  const baseSubtitleSize = parseInt(subtitleFontSizeEl?.value || 18);
  const citySize = Math.round(baseCitySize * scale * (isLandscape ? 0.85 : 1));
  ctx.font = `${cityWeight} ${citySize}px ${font}`;
  ctx.fillStyle = theme.text;
  const cityUpper = city.toUpperCase();
  const spacing = citySpacing * scale;
  let tw = 0;
  for (const c of cityUpper) tw += ctx.measureText(c).width + spacing;
  tw -= spacing;
  let x = textX - tw / 2;
  for (const c of cityUpper) { ctx.fillText(c, x + ctx.measureText(c).width / 2, textY); x += ctx.measureText(c).width + spacing; }
  
  const lineY = textY + citySize * 0.35;
  if (separatorStyle === 'line') {
    ctx.strokeStyle = theme.text + '40'; ctx.lineWidth = scale;
    ctx.beginPath(); ctx.moveTo(textX - 30*scale, lineY); ctx.lineTo(textX + 30*scale, lineY); ctx.stroke();
  } else if (separatorStyle === 'dots') {
    ctx.fillStyle = theme.text + '60';
    const dotR = 2 * scale;
    ctx.beginPath();
    ctx.arc(textX - 26*scale, lineY, dotR, 0, Math.PI * 2);
    ctx.arc(textX + 26*scale, lineY, dotR, 0, Math.PI * 2);
    ctx.fill();
  }
  
  const countrySize = Math.round(baseSubtitleSize * scale);
  ctx.font = `${subtitleWeight} ${countrySize}px ${font}`;
  ctx.fillStyle = theme.text + 'cc';
  const countryUpper = country.toUpperCase();
  ctx.fillText(countryUpper, textX, lineY + countrySize * 1.4);
  const countryWidth = ctx.measureText(countryUpper).width;
  
  let coordWidth = 0;
  if (showCoords) {
    const coordSize = Math.round(12 * scale);
    ctx.font = `300 ${coordSize}px ${font}`;
    ctx.fillStyle = theme.text + '88';
    const lat = data.lat, lon = data.lon;
    const coords = `${Math.abs(lat).toFixed(4)}°${lat >= 0 ? 'N' : 'S'}, ${Math.abs(lon).toFixed(4)}°${lon >= 0 ? 'E' : 'W'}`;
    ctx.fillText(coords, textX, lineY + countrySize * 1.4 + coordSize * 1.6);
    coordWidth = ctx.measureText(coords).width;
  }

  // Update text bounds for drag hit-testing (preview only)
  if (isPreview && cvs === canvas) {
    const blockWidth = Math.max(tw, countryWidth, coordWidth);
    const blockTop = textY - citySize;
    const blockBottom = lineY + countrySize * 1.4 + (showCoords ? (Math.round(12 * scale) * 1.6) : 0);
    lastTextBounds = {
      left: textX - blockWidth / 2,
      right: textX + blockWidth / 2,
      top: blockTop,
      bottom: blockBottom
    };
  }
  
  // Draw map boundary indicator (only in preview mode)
  if (isPreview && !ignorePanZoom && zoom === 1 && panX === 0 && panY === 0) {
    ctx.strokeStyle = theme.text + '20';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(margin, mapTop, mapW, mapH);
    ctx.setLineDash([]);
  }

  if (isPreview && cvs === canvas) {
    scheduleFit();
  }
}

function renderSvg(themeKey, sizeOverride, options) {
  if (!data) return null;
  const size = sizeOverride || getSize();
  const { w, h, orient } = size;
  const bleedPx = Math.max(0, options?.bleedPx || 0);
  const svgW = w + bleedPx * 2;
  const svgH = h + bleedPx * 2;
  const theme = THEMES[themeKey];
  const roadWeight = DEFAULT_ROAD_WEIGHT;
  const font = fontStyleEl?.value || 'system-ui, sans-serif';
  const cityWeight = parseInt(cityWeightEl?.value || 300, 10);
  const subtitleWeight = parseInt(subtitleWeightEl?.value || 400, 10);
  const citySpacing = parseInt(citySpacingEl?.value || 10, 10);
  const separatorStyle = separatorStyleEl?.value || 'line';
  const showCoords = showCoordsEl?.checked !== false;
  const { city, country } = getDisplayNames();
  const mapTransform = getExportMapTransform(size);
  
  const margin = Math.min(w, h) * 0.05;
  const isLandscape = orient === 'landscape';
  const mapW = w - margin * 2;
  const mapH = isLandscape ? h * 0.68 : h * 0.72;
  const mapTop = margin;
  
  const b = data.bounds;
  const dataAspect = (b.maxLon - b.minLon) / (b.maxLat - b.minLat);
  const mapAspect = mapW / mapH;
  const adj = { ...b };
  
  if (dataAspect > mapAspect) {
    const latC = (b.minLat + b.maxLat) / 2, range = (b.maxLon - b.minLon) / mapAspect;
    adj.minLat = latC - range / 2; adj.maxLat = latC + range / 2;
  } else {
    const lonC = (b.minLon + b.maxLon) / 2, range = (b.maxLat - b.minLat) * mapAspect;
    adj.minLon = lonC - range / 2; adj.maxLon = lonC + range / 2;
  }
  
  const proj = (lat, lon) => [
    margin + ((lon - adj.minLon) / (adj.maxLon - adj.minLon)) * mapW,
    mapTop + ((adj.maxLat - lat) / (adj.maxLat - adj.minLat)) * mapH
  ];
  
  const fmt = n => Number.isFinite(n) ? n.toFixed(SVG_PRECISION) : '0';
  const fmtT = n => Number.isFinite(n) ? n.toFixed(2) : '0';
  const pathFromGeom = (geom, closePath) => {
    if (!geom || !geom.length) return '';
    let d = '';
    geom.forEach((p, i) => {
      const [x, y] = proj(p.lat, p.lon);
      d += (i === 0 ? 'M' : 'L') + fmt(x) + ' ' + fmt(y);
    });
    if (closePath) d += 'Z';
    return d;
  };
  
  const waterFill = [];
  const waterStroke = [];
  if (waterEl.checked && data.water?.elements) {
    data.water.elements.forEach(el => {
      if (!el.geometry) return;
      const g = el.geometry;
      const isClosed = g[0].lat === g[g.length - 1].lat && g[0].lon === g[g.length - 1].lon;
      const isCoastline = el.tags?.natural === 'coastline';
      const d = pathFromGeom(g, isClosed);
      if (!d) return;
      if (isClosed && !isCoastline) waterFill.push(d);
      else waterStroke.push(d);
    });
  }
  
  const groups = { motorway: [], primary: [], secondary: [], tertiary: [], residential: [] };
  (data.streets.elements || []).forEach(el => {
    if (el.type !== 'way' || !el.geometry) return;
    const hw = el.tags?.highway?.replace('_link', '') || '';
    if (hw === 'motorway' || hw === 'trunk') groups.motorway.push(el);
    else if (hw === 'primary') groups.primary.push(el);
    else if (hw === 'secondary') groups.secondary.push(el);
    else if (hw === 'tertiary') groups.tertiary.push(el);
    else groups.residential.push(el);
  });
  
  const roadOrder = ['residential', 'tertiary', 'secondary', 'primary', 'motorway'];
  const roadPaths = roadOrder.map(group => {
    let d = '';
    groups[group].forEach(r => {
      d += pathFromGeom(r.geometry, false);
    });
    return d;
  });

  const mapParts = [
    waterFill.length ? `<path d="${waterFill.join('')}" fill="${theme.water}" stroke="none" />` : '',
    waterStroke.length ? `<path d="${waterStroke.join('')}" fill="none" stroke="${theme.water}" stroke-width="${(1.5 * roadWeight).toFixed(2)}" stroke-linecap="round" stroke-linejoin="round" />` : '',
    roadPaths.map((d, i) => d
      ? `<path d="${d}" fill="none" stroke="${theme.roads[4 - i]}" stroke-width="${(BASE_WIDTHS[4 - i] * roadWeight).toFixed(2)}" stroke-linecap="round" stroke-linejoin="round" />`
      : ''
    ).join('')
  ].filter(Boolean).join('');

  let mapGroup = mapParts;
  if (mapTransform && mapParts) {
    const cx = w / 2;
    const cy = h / 2;
    const tx = cx + mapTransform.panX;
    const ty = cy + mapTransform.panY;
    const transform = `translate(${fmtT(tx)} ${fmtT(ty)}) scale(${mapTransform.zoom.toFixed(4)}) translate(${fmtT(-cx)} ${fmtT(-cy)})`;
    mapGroup = `<g transform="${transform}">${mapParts}</g>`;
  }
  
  const bgColor = expandHex(theme.bg);
  const textColor = expandHex(theme.text);
  const fadeH = h * 0.08;
  const baseTextY = mapTop + mapH + margin * (isLandscape ? 0.6 : 0.8);
  const textX = w / 2 + textOffsetX * w;
  const textY = baseTextY + textOffsetY * h;
  const baseCitySize = parseInt(cityFontSizeEl?.value || 48);
  const baseSubtitleSize = parseInt(subtitleFontSizeEl?.value || 18);
  const citySize = Math.round(baseCitySize * (isLandscape ? 0.85 : 1));
  const countrySize = Math.round(baseSubtitleSize);
  const lineY = textY + citySize * 0.35;
  const sepOffset = 30;
  let separatorSvg = '';
  if (separatorStyle === 'line') {
    separatorSvg = `<line x1="${(textX - sepOffset).toFixed(2)}" y1="${lineY.toFixed(2)}" x2="${(textX + sepOffset).toFixed(2)}" y2="${lineY.toFixed(2)}" stroke="${textColor}40" stroke-width="1" />`;
  } else if (separatorStyle === 'dots') {
    const dotR = 2;
    separatorSvg = [
      `<circle cx="${(textX - 26).toFixed(2)}" cy="${lineY.toFixed(2)}" r="${dotR}" fill="${textColor}60" />`,
      `<circle cx="${(textX + 26).toFixed(2)}" cy="${lineY.toFixed(2)}" r="${dotR}" fill="${textColor}60" />`
    ].join('');
  }
  
  const cityText = escapeXml((city || '').toUpperCase());
  const countryText = escapeXml((country || '').toUpperCase());
  const coords = showCoords
    ? `${Math.abs(data.lat).toFixed(4)}°${data.lat >= 0 ? 'N' : 'S'}, ${Math.abs(data.lon).toFixed(4)}°${data.lon >= 0 ? 'E' : 'W'}`
    : '';
  
  const content = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}" viewBox="0 0 ${svgW} ${svgH}">`,
    `<defs>`,
    `<linearGradient id="fadeTop" x1="0" y1="0" x2="0" y2="1">`,
    `<stop offset="0%" stop-color="${bgColor}" />`,
    `<stop offset="100%" stop-color="${bgColor}" stop-opacity="0" />`,
    `</linearGradient>`,
    `<linearGradient id="fadeBottom" x1="0" y1="0" x2="0" y2="1">`,
    `<stop offset="0%" stop-color="${bgColor}" stop-opacity="0" />`,
    `<stop offset="100%" stop-color="${bgColor}" />`,
    `</linearGradient>`,
    `</defs>`,
    `<rect width="100%" height="100%" fill="${bgColor}" />`,
    bleedPx
      ? `<g transform="translate(${fmtT(bleedPx)} ${fmtT(bleedPx)})">` +
          [
            mapGroup,
            `<rect x="0" y="0" width="${w}" height="${fadeH}" fill="url(#fadeTop)" />`,
            `<rect x="0" y="${mapTop + mapH - fadeH}" width="${w}" height="${fadeH * 1.5}" fill="url(#fadeBottom)" />`,
            `<text x="${textX.toFixed(2)}" y="${textY.toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="${citySize}" font-weight="${cityWeight}" letter-spacing="${citySpacing}" fill="${textColor}">${cityText}</text>`,
            separatorSvg,
            `<text x="${textX.toFixed(2)}" y="${(lineY + countrySize * 1.4).toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="${countrySize}" font-weight="${subtitleWeight}" fill="${textColor}cc">${countryText}</text>`,
            showCoords ? `<text x="${textX.toFixed(2)}" y="${(lineY + countrySize * 1.4 + 12 * 1.6).toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="12" font-weight="300" fill="${textColor}88">${escapeXml(coords)}</text>` : ''
          ].filter(Boolean).join('') +
        `</g>`
      : [
          mapGroup,
          `<rect x="0" y="0" width="${w}" height="${fadeH}" fill="url(#fadeTop)" />`,
          `<rect x="0" y="${mapTop + mapH - fadeH}" width="${w}" height="${fadeH * 1.5}" fill="url(#fadeBottom)" />`,
          `<text x="${textX.toFixed(2)}" y="${textY.toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="${citySize}" font-weight="${cityWeight}" letter-spacing="${citySpacing}" fill="${textColor}">${cityText}</text>`,
          separatorSvg,
          `<text x="${textX.toFixed(2)}" y="${(lineY + countrySize * 1.4).toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="${countrySize}" font-weight="${subtitleWeight}" fill="${textColor}cc">${countryText}</text>`,
          showCoords ? `<text x="${textX.toFixed(2)}" y="${(lineY + countrySize * 1.4 + 12 * 1.6).toFixed(2)}" text-anchor="middle" font-family="${escapeXml(font)}" font-size="12" font-weight="300" fill="${textColor}88">${escapeXml(coords)}</text>` : ''
        ].filter(Boolean).join(''),
    `</svg>`
  ].filter(Boolean).join('');
  
  return content;
}
</script>
<script>
// === LOADING UI HELPERS ===
let loadStartTime = 0;
let loadingInterval = null;

function resetLoadingUI() {
  [step1, step2, step3, step4].forEach(s => {
    s.classList.remove('active', 'complete');
    s.querySelector('.step-icon').textContent = s.id.replace('step', '');
  });
  step1Detail.textContent = 'Finding city limits...';
  step2Detail.textContent = 'Waiting...';
  step3Detail.textContent = 'Waiting...';
  step4Detail.textContent = 'Waiting...';
  loadingPct.textContent = '0%';
  loadingStats.textContent = '';
  loadingProgressBar.style.width = '0%';
}

function setStep(num, status, detail) {
  const stepEl = $('step' + num);
  const detailEl = $('step' + num + 'Detail');
  
  if (status === 'active') {
    stepEl.classList.add('active');
    stepEl.classList.remove('complete');
  } else if (status === 'complete') {
    stepEl.classList.remove('active');
    stepEl.classList.add('complete');
    stepEl.querySelector('.step-icon').textContent = '✓';
  }
  
  if (detail) detailEl.textContent = detail;
}

function updateLoadingProgress(pct, stats) {
  loadingPct.textContent = Math.round(pct) + '%';
  loadingProgressBar.style.width = pct + '%';
  if (stats) loadingStats.textContent = stats;
}

function updateLoadingTime() {
  const elapsed = Math.round((Date.now() - loadStartTime) / 1000);
  loadingTime.textContent = `Elapsed: ${elapsed}s`;
}

// === GENERATE ===
genBtn.onclick = async () => {
  if (!place) { status('Select a city first'); return; }
  
  abortActiveRequests();
  genBtn.disabled = true;
  dlBtn.disabled = true;
  dlSvgBtn.disabled = true;
  compareBtn.disabled = true;
  zoom = 1; panX = 0; panY = 0;
  
  // Show loading overlay
  loadingOverlay.classList.remove('hidden');
  updatePreviewHint();
  resetLoadingUI();
  loadingCity.textContent = `Generating ${place.name || 'Map'}...`;
  loadStartTime = Date.now();
  loadingInterval = setInterval(updateLoadingTime, 1000);
  
  try {
    // Step 1: Resolve boundary
    setStep(1, 'active', 'Finding city limits...');
    updateLoadingProgress(5);
    status('Resolving city boundary...', false, true);
    setProgress(5);
    
    let areaId = null;
    let boundaryInfo = null;
    if (place.osm_type === 'relation' && place.osm_id) {
      boundaryInfo = { id: place.osm_id, adminLevel: '', name: place.name || '', score: 0 };
      areaId = 3600000000 + boundaryInfo.id;
      setStep(1, 'complete', `OSM relation ${place.osm_id}`);
    } else {
      const nameHint = customCityEl.value.trim() || place.name || selectedEl.dataset.city || '';
      const countryHint = customCountryEl.value.trim() || place.address?.country || selectedEl.dataset.country || '';
      boundaryInfo = await fetchBoundaryRelationFromNames(place.lat, place.lon, [nameHint], countryHint, null);
      if (!boundaryInfo) {
        try {
          const geo = await fetchGeocodeCached(nameHint, countryHint);
          const feature = geo.features?.[0];
          const countryCode = feature?.properties?.countrycode || '';
          const altNames = extractNameHintsFromPhoton(feature);
          boundaryInfo = await fetchBoundaryRelationFromNames(place.lat, place.lon, [nameHint, ...altNames], countryHint, countryCode);
        } catch (e) { /* ignore */ }
      }
      if (boundaryInfo?.id) {
        areaId = 3600000000 + boundaryInfo.id;
        setStep(1, 'complete', `Boundary relation ${boundaryInfo.id}`);
      } else {
        setStep(1, 'complete', 'Using radius-based area');
      }
    }
    setBoundaryDebug(boundaryInfo);
    updateLoadingProgress(10);
    
    let boundaryBounds = null;
    if (boundaryInfo?.id) boundaryBounds = await fetchBoundaryBounds(boundaryInfo.id);
    const preset = radiusPreset?.value || 'standard';
    const mult = RADIUS_PRESETS[preset] || 1;
    const baseRadius = boundaryBounds ? radiusFromBounds(boundaryBounds) : DEFAULT_RADIUS;
    const radius = Math.min(MAX_RADIUS, Math.max(3000, Math.round(baseRadius * mult)));
    lastFetch = { areaId, lat: place.lat, lon: place.lon, radius, boundaryBounds, radiusPreset: preset };
    
    // Step 2: Fetch streets
    setStep(2, 'active', 'Connecting to Overpass API...');
    updateLoadingProgress(15);
    
    const streetFetch = await fetchStreetsCached(areaId, place.lat, place.lon, radius);
    const streetResult = streetFetch.result;
    const streetCount = streetResult.elements?.length || 0;
    setStep(2, 'complete', `${streetCount.toLocaleString()} roads loaded${streetFetch.fromCache ? ' (cached)' : ''}`);
    updateLoadingProgress(55, `${streetCount.toLocaleString()} roads`);
    setProgress(55);
    
    // Step 3: Fetch water
    setStep(3, 'active', 'Fetching rivers, lakes...');
    updateLoadingProgress(60);
    
    const waterFetch = await fetchWaterCached(areaId, place.lat, place.lon, radius);
    const waterResult = waterFetch.result;
    const waterCount = waterResult.elements?.length || 0;
    setStep(3, 'complete', `${waterCount.toLocaleString()} water features${waterFetch.fromCache ? ' (cached)' : ''}`);
    updateLoadingProgress(85, `${streetCount.toLocaleString()} roads, ${waterCount.toLocaleString()} water`);
    setProgress(85);
    
    // Step 4: Render
    setStep(4, 'active', 'Drawing map...');
    updateLoadingProgress(90);
    
    const emptyData = streetCount === 0 && waterCount === 0;
    let bounds = calcBounds({ elements: streetResult.elements }, { elements: waterResult.elements });
    bounds = mergeBoundsSafe(bounds, boundaryBounds);
    if (!bounds) {
      bounds = fallbackBounds(place.lat, place.lon, radius);
      status('No data returned. Rendering fallback view.', false, true);
      setStep(4, 'active', 'Rendering fallback...');
    }
    bounds = normalizeBounds(bounds);
    data = {
      streets: { elements: streetResult.elements },
      water: { elements: waterResult.elements },
      bounds,
      lat: place.lat,
      lon: place.lon,
      city: selectedEl.dataset.city || place.name || '',
      country: selectedEl.dataset.country || place.address?.country || ''
    };
    data.groups = buildRoadGroups(data.streets.elements);
    data.totalRoads = data.streets.elements?.length || 0;
    data.totalWater = data.water.elements?.length || 0;
    data.totalFeatures = data.totalRoads + data.totalWater;
    dataVersion += 1;
    invalidatePreviewLayer();
    updateAutoTextInputs();
    
    render(canvas, themeEl.value, true);
    setStep(4, 'complete', 'Preview ready');
    updateLoadingProgress(100);
    setProgress(100);
    
    // Brief pause to show completion
    await new Promise(r => setTimeout(r, 400));
    
    if (emptyData) status('No streets or water found. Showing fallback bounds.');
    else status(`${streetCount.toLocaleString()} roads${waterCount ? `, ${waterCount.toLocaleString()} water features` : ''}`);
    
    dlBtn.disabled = false;
    dlSvgBtn.disabled = false;
    compareBtn.disabled = false;
    canvasToolbar.classList.add('visible');
    scheduleFit();
    
    if (pendingViewState) {
      applyViewState(pendingViewState);
      pendingViewState = null;
      render(canvas, themeEl.value, true);
    }
    scheduleStateSave();
    
  } catch (e) {
    console.error(e);
    status('Error: ' + e.message, true);
  } finally {
    genBtn.disabled = false;
    clearInterval(loadingInterval);
    loadingOverlay.classList.add('hidden');
    setTimeout(() => setProgress(null), 500);
    updatePreviewHint();
    updateSpacingLabel();
  }
};

// === DOWNLOAD ===
dlBtn.onclick = () => {
  if (!data) return;
  status('Generating full resolution...', false, true);
  const { city } = getDisplayNames();
  const size = getSize();
  const bleedPx = getBleedPx();
  
  const mapTransform = getExportMapTransform(size);
  if (bleedPx > 0) {
    const temp = document.createElement('canvas');
    temp.width = size.w;
    temp.height = size.h;
    render(temp, themeEl.value, false, 1, size, { mapTransform });
    
    offscreen.width = size.w + bleedPx * 2;
    offscreen.height = size.h + bleedPx * 2;
    const ctx = offscreen.getContext('2d');
    ctx.fillStyle = expandHex(THEMES[themeEl.value].bg);
    ctx.fillRect(0, 0, offscreen.width, offscreen.height);
    ctx.drawImage(temp, bleedPx, bleedPx);
  } else {
    offscreen.width = size.w;
    offscreen.height = size.h;
    render(offscreen, themeEl.value, false, 1, size, { mapTransform });
  }
  
  offscreen.toBlob(blob => {
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    const suffix = bleedPx > 0 ? '-bleed' : '';
    a.download = `${city.toLowerCase().replace(/\s+/g, '-')}-${size.label}-${size.orient}${suffix}.png`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    status('Downloaded!');
  }, 'image/png');
};

dlSvgBtn.onclick = () => {
  if (!data) return;
  status('Generating SVG...', false, true);
  const { city } = getDisplayNames();
  const size = getSize();
  const bleedPx = getBleedPx();
  const svg = renderSvg(themeEl.value, size, { bleedPx });
  if (!svg) { status('SVG export failed', true); return; }
  
  const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url;
  const suffix = bleedPx > 0 ? '-bleed' : '';
  a.download = `${city.toLowerCase().replace(/\s+/g, '-')}-${size.label}-${size.orient}${suffix}.svg`;
  a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  status('Downloaded!');
};

// === ZOOM ===
zoomIn.onclick = () => { zoom = Math.min(zoom * 1.2, 5); zoomLevel.textContent = Math.round(zoom * 100) + '%'; render(canvas, themeEl.value, true); scheduleStateSave(); };
zoomOut.onclick = () => { zoom = Math.max(zoom / 1.2, 0.5); zoomLevel.textContent = Math.round(zoom * 100) + '%'; render(canvas, themeEl.value, true); scheduleStateSave(); };
zoomReset.onclick = () => { zoom = 1; panX = 0; panY = 0; zoomLevel.textContent = '100%'; render(canvas, themeEl.value, true); scheduleStateSave(); };

let renderQueued = false;
let progressiveToken = 0;
function scheduleRender() {
  if (!data || renderQueued) return;
  renderQueued = true;
  requestAnimationFrame(() => {
    renderQueued = false;
    if (data) render(canvas, themeEl.value, true);
  });
}

function scheduleFit() {
  if (fitQueued) return;
  fitQueued = true;
  requestAnimationFrame(() => {
    fitQueued = false;
    fitPreviewToViewport();
  });
}

function withRenderLock(task) {
  const next = renderQueue.then(task, task);
  renderQueue = next.catch(() => {});
  return next;
}

function fitPreviewToViewport() {
  if (!previewRender || !canvas) return;
  const col = document.querySelector('.col-preview');
  const wrapper = document.getElementById('canvasWrapper');
  if (!col || !wrapper) return;
  
  const rect = col.getBoundingClientRect();
  const style = getComputedStyle(col);
  const padX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
  const padY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
  let availW = rect.width - padX;
  let availH = rect.height - padY;
  
  if (canvasToolbar && canvasToolbar.classList.contains('visible')) {
    availH -= canvasToolbar.getBoundingClientRect().height + 12;
  }
  if (statusEl) {
    availH -= statusEl.getBoundingClientRect().height + 16;
  }
  
  availW = Math.max(100, availW);
  availH = Math.max(100, availH);
  
  const scale = Math.min(availW / previewRender.w, availH / previewRender.h, 1);
  const cssW = Math.round(previewRender.w * scale);
  const cssH = Math.round(previewRender.h * scale);
  
  wrapper.style.width = cssW + 'px';
  wrapper.style.height = cssH + 'px';
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
}

window.addEventListener('resize', scheduleFit);
window.addEventListener('resize', updateMobileBlocker);

let isPanning = false, lastX, lastY, snapTimeout;
const SNAP_THRESHOLD = 15;

function showSnap(msg) {
  snapIndicator.textContent = msg;
  snapIndicator.classList.add('visible');
  clearTimeout(snapTimeout);
  snapTimeout = setTimeout(() => snapIndicator.classList.remove('visible'), 800);
}

function applySnap() {
  if (!snapEnabled) return;
  let snapped = false;
  const snapX = Math.abs(panX) < SNAP_THRESHOLD;
  const snapY = Math.abs(panY) < SNAP_THRESHOLD;
  if (snapX) { panX = 0; snapped = true; }
  if (snapY) { panY = 0; snapped = true; }
  if (snapped) showSnap(snapX && snapY ? 'Centered' : snapX ? 'Centered H' : 'Centered V');
}

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY,
    scaleX,
    scaleY
  };
}

function pointInTextBounds(x, y) {
  if (!lastTextBounds) return false;
  return x >= lastTextBounds.left && x <= lastTextBounds.right && y >= lastTextBounds.top && y <= lastTextBounds.bottom;
}

canvas.onmousemove = e => {
  if (isPanning || isTextDragging) return;
  if (textMoveEnabled && lastTextBounds) {
    const { x, y } = getCanvasPoint(e);
    canvas.style.cursor = pointInTextBounds(x, y) ? 'move' : 'grab';
  } else {
    canvas.style.cursor = 'grab';
  }
};

canvas.onmousedown = e => {
  const { x, y } = getCanvasPoint(e);
  if (textMoveEnabled && pointInTextBounds(x, y)) {
    isTextDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
    return;
  }
  isPanning = true;
  lastX = e.clientX;
  lastY = e.clientY;
  canvas.style.cursor = 'grabbing';
};

document.onmousemove = e => {
  if (!isPanning && !isTextDragging) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const dx = (e.clientX - lastX) * scaleX;
  const dy = (e.clientY - lastY) * scaleY;
  lastX = e.clientX;
  lastY = e.clientY;
  
  if (isTextDragging) {
    textOffsetX += dx / canvas.width;
    textOffsetY += dy / canvas.height;
    scheduleRender();
    return;
  }
  
  panX += dx;
  panY += dy;
  applySnap();
  scheduleRender();
};

document.onmouseup = () => {
  if (isPanning) applySnap();
  isPanning = false;
  isTextDragging = false;
  canvas.style.cursor = textMoveEnabled ? 'move' : 'grab';
  scheduleStateSave();
};

canvas.onwheel = e => {
  if (!data) return;
  e.preventDefault();
  const { x, y } = getCanvasPoint(e);
  const prevZoom = zoom;
  const factor = Math.exp(-e.deltaY * 0.0015);
  zoom = Math.min(Math.max(zoom * factor, 0.5), 5);
  const scale = zoom / prevZoom;
  const cx = x - canvas.width / 2;
  const cy = y - canvas.height / 2;
  panX = (1 - scale) * cx + scale * panX;
  panY = (1 - scale) * cy + scale * panY;
  zoomLevel.textContent = Math.round(zoom * 100) + '%';
  scheduleRender();
  scheduleStateSave();
};

// === COMPARE MODAL ===
let lastFocusedEl = null;
function getFocusable(el) {
  return Array.from(el.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'))
    .filter(node => !node.disabled && node.getClientRects().length > 0);
}

function trapFocus(modalEl, e) {
  if (e.key !== 'Tab') return;
  const focusable = getFocusable(modalEl);
  if (!focusable.length) return;
  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  if (e.shiftKey && document.activeElement === first) {
    e.preventDefault();
    last.focus();
  } else if (!e.shiftKey && document.activeElement === last) {
    e.preventDefault();
    first.focus();
  }
}

function openModal(modalEl) {
  lastFocusedEl = document.activeElement;
  modalEl.classList.add('open');
  modalEl.setAttribute('aria-hidden', 'false');
  const focusable = getFocusable(modalEl);
  if (focusable.length) focusable[0].focus();
  if (!modalEl._focusTrap) modalEl._focusTrap = e => trapFocus(modalEl, e);
  modalEl.addEventListener('keydown', modalEl._focusTrap);
}

function closeModal(modalEl) {
  modalEl.classList.remove('open');
  modalEl.setAttribute('aria-hidden', 'true');
  if (modalEl._focusTrap) modalEl.removeEventListener('keydown', modalEl._focusTrap);
  if (lastFocusedEl && typeof lastFocusedEl.focus === 'function') lastFocusedEl.focus();
}

compareBtn.onclick = () => {
  if (!data) return;
  openModal(modal);
  themeGrid.innerHTML = '';
  
  Object.entries(THEMES).forEach(([key, theme]) => {
    const card = document.createElement('div');
    card.className = 'theme-card';
    const cvs = document.createElement('canvas');
    render(cvs, key, true, 0.2, null, { ignorePanZoom: true });
    card.appendChild(cvs);
    const info = document.createElement('div');
    info.className = 'theme-card-info';
    info.innerHTML = `<span class="theme-card-name">${theme.name}</span><button class="btn btn-primary" style="padding:6px 12px; font-size:10px;">Select</button>`;
    info.querySelector('button').onclick = () => { themeEl.value = key; render(canvas, key, true); closeModal(modal); };
    card.appendChild(info);
    themeGrid.appendChild(card);
  });
};
modalClose.onclick = () => closeModal(modal);
if (searchClose && searchModal) {
  searchClose.onclick = () => closeModal(searchModal);
}

// === BATCH MODAL ===
batchBtn.onclick = () => openModal(batchModal);
batchClose.onclick = () => closeModal(batchModal);

function appendBatchLog(text, color) {
  const line = document.createElement('div');
  line.textContent = text;
  if (color) line.style.color = color;
  batchLog.appendChild(line);
}

batchStart.onclick = async () => {
  const lines = batchInput.value.split('\n').map(l => l.trim()).filter(l => l && l.includes(','));
  if (!lines.length) { batchStatus.textContent = 'No valid cities'; return; }
  
  abortActiveRequests();
  batchStart.disabled = true;
  batchLog.textContent = '';
  batchProgress.classList.add('active');
  batchProgressBar.style.width = '0%';
  const results = [];
  const total = lines.length;
  let completed = 0;
  let success = 0;
  let failed = 0;
  let active = 0;
  const queue = [...lines];
  
  const updateStatus = () => {
    batchStatus.textContent = `Processing ${completed}/${total} • ${success} ok, ${failed} failed${active ? ` • ${active} in flight` : ''}`;
    batchProgressBar.style.width = ((completed / total) * 100) + '%';
  };
  updateStatus();
  
  async function processCity(cityName, countryName) {
    for (let attempt = 1; attempt <= BATCH_MAX_RETRIES; attempt++) {
      try {
        const geoData = await fetchGeocodeCached(cityName, countryName);
        if (!geoData.features?.length) throw new Error('City not found');
        
        const feature = geoData.features[0];
        const [lon, lat] = feature.geometry.coordinates;
        const osmId = feature.properties.osm_id;
        const osmType = feature.properties.osm_type;
        
        let areaId = null;
        let boundaryInfo = null;
        if (osmType === 'R' && osmId) { boundaryInfo = { id: osmId, adminLevel: '', name: cityName, score: 0 }; areaId = 3600000000 + osmId; }
        if (!areaId) {
          const altNames = extractNameHintsFromPhoton(feature);
          const countryCode = feature?.properties?.countrycode || '';
          boundaryInfo = await fetchBoundaryRelationFromNames(lat, lon, [cityName, ...altNames], countryName, countryCode);
          if (boundaryInfo?.id) areaId = 3600000000 + boundaryInfo.id;
        }
        
        let boundaryBounds = null;
        if (boundaryInfo?.id) boundaryBounds = await fetchBoundaryBounds(boundaryInfo.id);
        const preset = radiusPreset?.value || 'standard';
        const mult = RADIUS_PRESETS[preset] || 1;
        const baseRadius = boundaryBounds ? radiusFromBounds(boundaryBounds) : DEFAULT_RADIUS;
        const batchRadius = Math.min(MAX_RADIUS, Math.max(3000, Math.round(baseRadius * mult)));
        const streetFetch = await fetchStreetsCached(areaId, lat, lon, batchRadius);
        const waterFetch = await fetchWaterCached(areaId, lat, lon, batchRadius);
        const result = { streets: streetFetch.result, water: waterFetch.result };
        let bounds = calcBounds(result.streets, result.water);
        bounds = mergeBoundsSafe(bounds, boundaryBounds);
        if (!bounds) bounds = fallbackBounds(lat, lon, batchRadius);
        bounds = normalizeBounds(bounds);
        
        const tempData = { streets: result.streets, water: result.water, bounds, lat, lon, city: cityName, country: countryName };
        tempData.groups = buildRoadGroups(tempData.streets.elements);
        tempData.totalRoads = tempData.streets.elements?.length || 0;
        tempData.totalWater = tempData.water.elements?.length || 0;
        tempData.totalFeatures = tempData.totalRoads + tempData.totalWater;
        
        return await withRenderLock(async () => {
          const oldData = data;
          data = tempData;
          try {
            const [sizeVal, orientVal] = batchSize.value.split('-');
            const size = { w: SIZES[sizeVal][orientVal][0], h: SIZES[sizeVal][orientVal][1], orient: orientVal, label: sizeVal };
            
            offscreen.width = size.w;
            offscreen.height = size.h;
            render(offscreen, batchTheme.value, false, 1, size);
            
            const blob = await new Promise(r => offscreen.toBlob(r, 'image/png'));
            return { name: `${cityName.toLowerCase().replace(/\s+/g, '-')}.png`, blob };
          } finally {
            data = oldData;
          }
        });
      } catch (e) {
        if (attempt < BATCH_MAX_RETRIES) {
          appendBatchLog(`↻ ${cityName}: retrying (${attempt}/${BATCH_MAX_RETRIES})`, '#f5b942');
          await delay(1000 * attempt);
          continue;
        }
        throw e;
      }
    }
  }
  
  async function worker() {
    while (queue.length) {
      const line = queue.shift();
      if (!line) return;
      const [cityName, countryName] = line.split(',').map(s => s.trim());
      active += 1;
      updateStatus();
      try {
        const result = await processCity(cityName, countryName);
        if (result) results.push(result);
        success += 1;
        appendBatchLog(`✓ ${cityName}`, '#4a9eff');
      } catch (e) {
        failed += 1;
        appendBatchLog(`✗ ${cityName}: ${e.message}`, '#e55');
      } finally {
        completed += 1;
        active -= 1;
        updateStatus();
      }
    }
  }
  
  const workers = Array.from({ length: Math.min(BATCH_MAX_PARALLEL, total) }, () => worker());
  await Promise.all(workers);
  
  // Download ZIP
  if (results.length) {
    batchStatus.textContent = 'Creating ZIP...';
    const { default: JSZip } = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm');
    const zip = new JSZip();
    results.forEach(r => zip.file(r.name, r.blob));
    const content = await zip.generateAsync({ type: 'blob' });
    const a = document.createElement('a');
    const url = URL.createObjectURL(content);
    a.href = url;
    a.download = 'map-posters.zip';
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }
  
  batchStatus.textContent = `Done! ${results.length}/${lines.length} generated${failed ? `, ${failed} failed` : ''}`;
  batchStart.disabled = false;
  batchProgress.classList.remove('active');
};

// === KEYBOARD ===
document.onkeydown = e => {
  if (e.key !== 'Escape') return;
  if (modal.classList.contains('open')) closeModal(modal);
  if (searchModal?.classList.contains('open')) closeModal(searchModal);
  if (batchModal.classList.contains('open')) closeModal(batchModal);
};

// === OPTION CHANGES ===
waterEl.onchange = async () => {
  invalidatePreviewLayer();
  if (!data) return;
  if (waterEl.checked && (data.water?.elements?.length || 0) === 0 && lastFetch) {
    status('Fetching water bodies...', false, true);
    try {
      const waterFetch = await fetchWaterCached(lastFetch.areaId, lastFetch.lat, lastFetch.lon, lastFetch.radius);
      data.water = { elements: waterFetch.result.elements || [] };
      data.totalWater = data.water.elements.length;
      data.totalFeatures = data.totalRoads + data.totalWater;
      let bounds = calcBounds(data.streets, data.water);
      bounds = mergeBoundsSafe(bounds, lastFetch.boundaryBounds);
      if (bounds) data.bounds = normalizeBounds(bounds);
      dataVersion += 1;
      status(`${data.totalRoads.toLocaleString()} roads, ${data.totalWater.toLocaleString()} water features`);
    } catch (e) {
      status('Water fetch failed: ' + e.message, true);
    }
  }
  if (data) render(canvas, themeEl.value, true);
  scheduleStateSave();
};
showCoordsEl.onchange = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
fontStyleEl.onchange = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
customCityEl.oninput = () => {
  if (!customCityEl.value.trim()) {
    delete customCityEl.dataset.userEdited;
    updateAutoTextInputs();
  } else {
    customCityEl.dataset.userEdited = '1';
  }
  if (data) render(canvas, themeEl.value, true);
  scheduleStateSave();
};
customCountryEl.oninput = () => {
  if (!customCountryEl.value.trim()) {
    delete customCountryEl.dataset.userEdited;
    updateAutoTextInputs();
  } else {
    customCountryEl.dataset.userEdited = '1';
  }
  if (data) render(canvas, themeEl.value, true);
  scheduleStateSave();
};
cityFontSizeEl.oninput = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
subtitleFontSizeEl.oninput = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
if (bleedToggle) bleedToggle.onchange = () => { scheduleStateSave(); };
if (cityWeightEl) cityWeightEl.onchange = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
if (subtitleWeightEl) subtitleWeightEl.onchange = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
if (separatorStyleEl) separatorStyleEl.onchange = () => { if (data) render(canvas, themeEl.value, true); scheduleStateSave(); };
if (citySpacingEl) {
  citySpacingEl.oninput = () => {
    updateSpacingLabel();
    if (data) render(canvas, themeEl.value, true);
    scheduleStateSave();
  };
}

// === INIT ===
window.addEventListener('load', () => {
  try {
    updateMobileBlocker();
    const debugBoundary = new URLSearchParams(window.location.search).has('debug') || localStorage.getItem('debugBoundary') === '1';
    if (debugBoundary) document.body.classList.add('debug');

    // Populate theme dropdown
    if (themeEl) {
      themeEl.innerHTML = Object.entries(THEMES).map(([key, t]) => 
        `<option value="${key}">${t.name} — ${t.desc}</option>`
      ).join('');
    }
    
    // Populate batch theme dropdown
    if (batchTheme && themeEl) {
      batchTheme.innerHTML = themeEl.innerHTML;
    }

    // Render city list
    if (typeof CITIES !== 'undefined') {
      renderCityList();
    } else {
      console.error('CITIES not loaded');
    }

    updatePreviewHint();
    
    // Restore state or auto-load Austin
    const urlState = readStateFromUrl();
    const storedState = urlState ? null : readStateFromStorage();
    const applied = urlState ? applyState(urlState) : (storedState ? applyState(storedState) : false);
    if (!applied) {
      setTimeout(() => {
        if (typeof selectCity === 'function') {
          selectCity('austin');
        }
      }, 200);
    }
  } catch (e) {
    console.error('Init error:', e);
  }
});
</script>
</body>
</html>
